---
title: 1001-采花生
date: 2019-09-30 0:53:52
categories: PAT练习
tags: 
- HashMap
---

## 题目描述 <!--more-->
鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！——熊字”。<br/>
鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说:“你先找出花生最多的植株，去采摘它的花生;然后再找出剩下的植株里花生最多的，去采摘它的花生;依此类推，不过你一定要在我限定的时间内回到路边。”<br/>
我们假定多多在每个单位时间内,可以做下列四件事情中的一件：<br/>
1. 从路边跳到最靠近路边（即第一行）的某棵花生植株；<br/>
2. 从一棵植株跳到前后左右与之相邻的另一棵植株；<br/>
3. 采摘一棵植株下的花生；<br/>
4. 从最靠近路边（即第一行）的某棵花生植株跳回路边。<br/>
现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？<br/>

注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。例如花生田里只有位于(2, 5), (3, 7), (4, 2), (5, 4)的植株下长有花生，个数分别为 13, 7, 15, 9。多多在 21 个单位时间内，只能经过(4, 2)、(2, 5)、(5, 4)，最多可以采到 37 个花生。

## 输入描述
>输入包含多组数据，每组数据第一行包括三个整数 M（1≤M≤20）、    n（1≤N≤20）和 K（0≤K≤1000），用空格隔开；表示花生田的大小为M * N，多多采花生的限定时间为 K个单位时间。
紧接着 M 行，每行包括 N 个自然数 P（0≤P≤500），用空格隔开；表 示花生田里植株下花生的数目，并且除了0（没有花生），其他所有植株下花生的数目都不相同。

## 输出描述:
>对应每一组数据，输出一个整数，即在限定时间内，多多最多可以采到花生的个数。

## 示例
### 输入
>6 7 21<br/>
>0 0 0 0 0 0 0<br/>
>0 0 0 0 13 0 0<br/>
>0 0 0 0 0 0 7<br/>
>0 15 0 0 0 0 0<br/>
>0 0 0 9 0 0 0<br/>
>0 0 0 0 0 0 0<br/>
### 输出
>37

## 解题思路：
* 我傻了<br/>
&#8195;
***
***
<br/>
<!-- lang:java-->

	import java.util.ArrayList;
	import java.util.Collections;
	import java.util.Comparator;
	import java.util.HashMap;
	import java.util.Scanner;
	import java.io.BufferedInputStream;
	
	public class second_1001_2 {
	    public static void main(String[] args) {
	        Scanner sc = new Scanner(new BufferedInputStream(System.in)); //传说能降低scanner用时
	        while(sc.hasNext()){
	            int y = sc.nextInt(); //竖列
	            int x = sc.nextInt(); //横行
	            int totalTime = sc.nextInt(); //限定时间
	            //创建HashMap，存放花生田里有花生的植株信息
	            HashMap<Integer, Node> map = new HashMap<Integer,Node>();
	            //初始化花生田
	            for (int i = 0; i < y; i++) {
	                for (int j =0;j < x;j++){
	                    int num = sc.nextInt();
	                    if(num != 0){
	                        map.put(num,new Node(i,j,num));
	                    }
	                }
	            }
	            //定义排序规则，按照花生数量从多到少降序排序
	            Comparator<Integer> cmp = new Comparator<Integer>() {
	                @Override
	                public int compare(Integer o1, Integer o2) {
	                    return o2 - o1;
	                }
	            };
	            //从Hashmap集合中取出键-花生数量放入ArrayList数组中
	            ArrayList<Integer> list = new ArrayList<Integer>(map.keySet());
	            if (list.isEmpty()) System.out.println(0);
	            else{
	                Collections.sort(list, cmp); //降序排序list
	                //定义list索引
	                int index = 0;
	                Node node = map.get(list.get(index++)); //获取零list索引的值，map中key对应的value，即y，x，num
	                // 定义移动时间，采摘时间，离开时间
	                int moveTime = node.y + 1;//第一次特化摘花生移动只用计算纵向距离，+1为计算机从零开始计算
	                int takeTime = 1, leavlTime = node.y + 1; //采摘消耗1单位时间，离开与第一次移动一样
	                int sum =0; //记录花生数量总和
	                //判断移动采摘返程是否超时
	                while (totalTime - moveTime - takeTime - leavlTime >= 0) {
	                    //未超时，总时间减去移动和采摘所要花费的时间
	                    totalTime = totalTime - moveTime - takeTime;
	                    //累加花生数量
	                    sum += node.num;
	                    //判断有无下一植株,有则结束循环
	                    if (index >= list.size()) break;
	                    //获取下一植株信息,结束后索引+1
	                    Node nextNode = map.get(list.get(index++));
	                    // 获取移动到下一植株的时间
	                    moveTime = Math.abs(node.y - nextNode.y)
	                            + Math.abs(node.x - nextNode.x); //绝对值
	                    // 获取从下一植株离开的时间
	                    leavlTime = nextNode.y + 1;
	                    node = nextNode; //下个植株标记为这个植株，进入下次循环
	                }
	                System.out.println(sum);
	            }
	        }
	    }
	}
	class Node {
		int y;
		int x;
		int num;
	
	    public Node(int y, int x, int num){
	        super();
	        this.y = y;
	        this.x = x;
	        this.num = num;
		}
	}

