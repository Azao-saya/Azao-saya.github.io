---
title: B1050-螺旋矩阵
date: 2019-11-3 1:34:12 
categories: PAT练习
tags: 
- 未AC题目
- 极其非面向对象
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/id=57171771(BoCuden).50wbrbiulzc0.jpg
---

## 题目描述 <!--more-->

-本题要求将给定的 *N* 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 *m* 行 *n* 列，满足条件：*m*×*n* 等于 *N*；*m*≥*n*；且 *m*−*n* 取所有可能值中的最小值。 

## 输入描述

>输入在第 1 行中给出一个正整数 *N*，第 2 行给出 *N* 个待填充的正整数。所有数字不超过 104，相邻数字以空格分隔。 

## 输出描述:

>输出螺旋矩阵。每行 *n* 个数字，共 *m* 行。相邻数字以 1 个空格分隔，行末不得有多余空格。 

## 示例

### 输入

> 12
> 37 76 20 98 76 42 53 95 60 81 58 93

### 输出

> 98 95 93
> 42 37 81
> 53 20 76
> 58 60 76

## 解题思路：

-  超时
-  这题挺晕的，大概就是先把拿到了数升序排序了。
-   因为 矩阵的规模为 *m* 行 *n* 列 ，*m*−*n* 取所有可能值中的最小值
-  N的开方乘N的开方就能得到这个最小值，矩阵的容量没有达到N再把m+1即可。
-  然后创建一个二维数组，控制i和j来完成上下左右移动
-  4个循环每个循环完会自增的那个数会越界，也就有各种加加减减。
-  遍历输出时，先直接输出一个不加空格的。
-  常态为17分，偶尔能通过一个测试点加两分
-  ![薛定谔](https://s2.ax1x.com/2019/11/26/MxwktA.png)

---

---



```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class PAT_B1050 {
    public static void main(String[] args) throws IOException {//超时 得分17
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        String[] temp = br.readLine().split(" ");
        int[] numbers = new int[temp.length];
        for (int i = 0; i <temp.length ; i++) {
            numbers[i] = Integer.parseInt(temp[i]);
        }
        Arrays.sort(numbers);
        int m,n;
        if (Math.sqrt(N)*(Math.sqrt(N)) < N){
            m = (int)Math.sqrt(N)+1;
            n = (int)Math.sqrt(N);
        }else {
            m = (int)Math.sqrt(N);
            n = (int)Math.sqrt(N);
        }
        int[][] arr = new int[m][n];
        int index = numbers.length-1;
        int i=0,j=0;
        while (index >= 0) {
            // right.
            for (; index >= 0 && j < n && arr[i][j] == 0; j++) {
                arr[i][j] = numbers[index--];
            }
            i++;
            j--;//最后一个j++溢出了

            // down.
            for (; index >= 0 && i < m && arr[i][j] == 0; i++) {
                arr[i][j] = numbers[index--];
            }

            i--;
            j--;

            // left.
            for (; index >= 0 && j >= 0 && arr[i][j] == 0; j--) {
                arr[i][j] = numbers[index--];
            }
            i--;
            j++;

            // up.
            for (; index >= 0 && i >= 0 && arr[i][j] == 0; i--) {
                arr[i][j] = numbers[index--];
            }
            i++;
            j++;
        }

        for (int p = 0; p < m; p++) {
            System.out.print(arr[p][0]);
            for (int q = 1; q < n; q++) {
                System.out.print(" " + arr[p][q]);
            }

            System.out.println();
        }
    }
}
```

