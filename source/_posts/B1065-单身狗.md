---

title: B1065-单身狗
date: 2019-11-6 9:34:12 
categories: PAT练习
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/id=56732959.5wf0xgo5yxs0.jpg
---

## 题目描述 <!--more-->

 “单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。 

## 输入描述

>   输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻/伴侣的对数；随后 N 行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10 000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。   

## 输出描述:

>  首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。 

## 示例

### 输入

> 3
> 11111 22222
> 33333 44444
> 55555 66666
> 7
> 55555 44444 10000 88888 22222 11111 23333

### 输出

> 5
> 10000 23333 44444 55555 88888

## 解题思路：

- 创建一个couples数组，丈夫索引存放妻子，妻子索引存放丈夫。

- 在创建一个isExist数组表示人是否到场，是单身狗有两种情况，一种是有伴侣但未到场另一种是没有伴侣。

- 逻辑有点绕

- ```
  isExist[couples[tempN]] = 1; //标记自己到场
  ```
  
- tempN如果是丈夫的话，couples[tempN]得到的是妻子的值，然后设置为isExist[妻子]=1

- 表示丈夫到场，也就是如果检测妻子是不是单身狗时isExist[妻子]会得到1

- 完成代码用到新的东西Arrays.fill(couples, -1);//数组初始化为-1，填充数组里的所有数

---

---



```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int couples[] = new int[100000];
        Arrays.fill(couples, -1);//数组初始化为-1
        for (int i = 0; i <n ; i++) {
            String[] temp = br.readLine().split(" ");
            int wife = Integer.parseInt(temp[0]);
            int husband = Integer.parseInt(temp[1]);
            couples[wife] = husband;
            couples[husband] = wife;
        }
        int m = Integer.parseInt(br.readLine());
        String[] guest = br.readLine().split(" ");
        int[] isExist = new int[100000];
        for (int i = 0; i <m ; i++) {
            int tempN = Integer.parseInt(guest[i]);
            if (couples[tempN] != -1){ //自己对应的对象存在
                isExist[couples[tempN]] = 1; //标记自己到场
            }
        }
        Set<Integer> set = new TreeSet<Integer>();
        for (int i = 0; i <m ; i++) {
            int tempN = Integer.parseInt(guest[i]);
            if (isExist[tempN] !=1){
                set.add(tempN);
            }
        }
        System.out.println(set.size());
        boolean isFirst = true;
        for (Integer integer : set) {
            if (!isFirst) {
                System.out.print(" ");
            }
            System.out.print(integer);
            isFirst = false;
        }
    }
}
```

