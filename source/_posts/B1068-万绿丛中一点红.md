---
title: B1068-万绿丛中一点红
date: 2019-11-8 12:34:12 
categories: PAT练习
tags:
- 祖传屎山代码
- 未AC题目
- try/catch
- 正则表达式
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/id=56732959.5wf0xgo5yxs0.jpg
---

## 题目描述 <!--more-->

 小明 PAT 考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔 N 个人就发出一个红包。请你编写程序帮助他确定中奖名单。 

## 输入描述

>    输入第一行给出三个正整数 M（≤ 1000）、N 和 S，分别是转发的总量、小明决定的中奖间隔、以及第一位中奖者的序号（编号从 1 开始）。随后 M 行，顺序给出转发微博的网友的昵称（不超过 20 个字符、不包含空格回车的非空字符串）。
>
>    注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。

## 输出描述:

>    按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出 `Keep going...`。 

## 示例

### 输入1

> 9 3 2
> Imgonnawin!
> PickMe
> PickMeMeMeee
> LookHere
> Imgonnawin!
> TryAgainAgain
> TryAgainAgain
> Imgonnawin!
> TryAgainAgain

### 输出1

> PickMe
> Imgonnawin!
> TryAgainAgain

### 输入2

> 2 3 5
> Imgonnawin!
> PickMe

### 输出2

> Not Unique

### 输入3

> 3 3 5
> 1 2 3
> 3 4 5
> 5 6 7

### 输出3

> Keep going...

## 解题思路：

- 看到三个输入样例因为就知道这题很麻烦了，太题目没说的东西了，当时就吐槽了。

- ```
  if (tx >= 0 && tx < n && ty >= 0 && ty < m && Math.abs(draw[i][j] - draw[tx][ty]) <= tol) return false;
  ```

- tx >= 0 && tx < n && ty >= 0 && ty < m,前面是用来限定要对比的最多8个数，没有超过边界。

- 一种是小于边界一种是大于边界

- Math.abs(draw[i][j] - draw[tx][ty]) <= tol ，后面是差值小于阈值。限定条件非常多都是与，要全部满足才会判false。

- 也就是如果超过边界的会直接跳过进入下一个循环，让其在边角上相邻不足8个数也能按照题意正常运行。

- 哎这只是一道20分的题，感觉已经是25分都算难了。pat难度幅度着实有点大了。

---

---



```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/**
 脏话%&*……&**，测试点4超时
 首先是题目要求的这样点不唯一，很容易就理解为这样的点超过两个，实际上它也是这个意思。
 然后输入案例1（4,2）处是满足周围色差超过阈值的。但为什么没把他算进去，因为这个不唯一还有一层意思就是不能有另外一个和他一样值的点
 这个算我没仔细看案例，解决了之后，提交，全错，再改.
 从遗留的try，catch可以看出。一开始我是以为边上一圈相邻不足8个直接就不用判断了。
 题目也是这样说的该点的颜色与其周围 8 个相邻像素的颜色差充分大。
 但实际上是周围相邻的满足就可以，就算相邻的只有一个点，两个点。只要满足就可以算一点红。
 所以呢，这种东西如果不是提交了错误了。到底要怎么发现啊。
 */
public class PAT_B1068 {
    static int tol;
    static int n;
    static int m;
    static int[][] draw = new int[1001][1001];
    static int dir[][] = new int[][]{{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};
                                    //代表了坐标左上，正上，右上，正右，右下，正下，左下，正左
                                    //dir[]第一个[]表示是除去最外圈的大括号的第几个{}，后一个[]表示{}内的第几个元素
    private static boolean isRed(int i ,int j){
        try{
            for (int k = 0; k < 8; k++) {
                int tx = i + dir[k][0];
                int ty = j + dir[k][1];
                if (tx >= 0 && tx < n && ty >= 0 && ty < m && Math.abs(draw[i][j] - draw[tx][ty]) <= tol) return false;
            }
        }catch (Exception e){
            return false;
        }
        return true;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] temp = br.readLine().split(" ");
        m = Integer.parseInt(temp[0]);
        n = Integer.parseInt(temp[1]);
        tol = Integer.parseInt(temp[2]);
        draw = new int[n][m];
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i <n ; i++) {
            String[] s =br.readLine().split("\\s+");
            for (int j = 0; j <m ; j++) {
                draw[i][j]= Integer.parseInt(s[j]);
                if(map.containsKey(draw[i][j]))
                    map.put(draw[i][j], 42); //42为随便设置的数，不为1就行，同一个值出现两次该点绝不会为一点红
                else
                    map.put(draw[i][j], 1);
            }
        }
        int count = 0;
        int x=0,y=0;
        boolean flag = false;
        boolean flag2 = false;
        wp:for (int i = 0; i <n ; i++) {
            for (int j = 0; j <m ; j++) {
                if (isRed(i,j) && map.get(draw[i][j])==1){
                    x = i ;
                    y = j ;
                    count++;
                }
            }
        }
        if (count ==0){
            System.out.println("Not Exist");
        } else if (count == 1) {
            System.out.printf("(%d, %d): %d", y+1, x+1, draw[x][y]);
        }else {
            System.out.println("Not Unique");
        }
    }
}
```

