---
title: B1015-德才论
date: 2019-10-16 11:45:12 
categories: PAT练习
tags:
- 未AC题目
- implements
- compare
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/QQ图片20200131234133.3wh4kqrq5s20.jpg
---

## 题目描述 <!--more-->

- 宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”

  现给出一批考生的德才分数，请根据司马光的理论给出录取排名。

## 输入描述

>   输入第一行给出 3 个正整数，分别为：*N*（≤105），即考生总数；*L*（≥60），为录取最低分数线，即德分和才分均不低于 *L* 的考生才有资格被考虑录取；*H*（<100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 *H*，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 *L* 的考生也按总分排序，但排在第三类考生之后。
>
>   随后 *N* 行，每行给出一位考生的信息，包括：`准考证号 德分 才分`，其中`准考证号`为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。

## 输出描述:

>    输出第一行首先给出达到最低分数线的考生人数 *M*，随后 *M* 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 

## 示例

### 输入

> 14 60 80
> 10000001 64 90
> 10000002 90 60
> 10000011 85 80
> 10000003 85 80
> 10000004 80 85
> 10000005 82 77
> 10000006 83 76
> 10000007 90 78
> 10000008 75 79
> 10000009 59 90
> 10000010 88 45
> 10000012 80 100
> 10000013 90 99
> 10000014 66 60

### 输出

> 12
> 10000013 90 99
> 10000012 80 100
> 10000003 85 80
> 10000011 85 80
> 10000004 80 85
> 10000007 90 78
> 10000006 83 76
> 10000005 82 77
> 10000002 90 60
> 10000014 66 60
> 10000008 75 79
> 10000001 64 90



## 解题思路：

-   compare函数的返回值-1、1、0 

- 分别代表负数不交换顺序

-  **`0`表示的是，相同元素不排序，要是我们把等于返回为`-1`，那么两个相同的元素会交换顺序。**虽然对两个数字而言交换顺序没有影响，但是如果是map对象则有影响。另外，如果相同时返回1，则结果和返回0是一样的，就是不排序。 

- 正数为交换顺序

- 升序写法为

- if(o1<o2)  return -1; *//(不交换顺序）*

-  if(o1==o2)  return 0; *//或者返回1效果是一样的；-1相同元素会发生位置调整（虽然两个相同的数字交换顺序没影响，但如果是map元素则有影响）*

-  if(o1>o2)  return 1; *//交换顺序*

-  倒序为反转大于小于号

-  总之就是第二个元素减第一个元素为降序

-  然后这里出现第一个无解解决的超时问题，只要用java这个测试点就过不了，挺打击我的。

   

------

-----

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class PAT_B1015 {
    // N考生总数  L最低分数线(德才分均要过线，否则不录入输出) H优先录取线
    // 准考证 德分d 才分c
    //1.高于H线按德才总分排序
    //2.才分c不到H线，但是德分d到了，按总分排序。排在第一类后面
    //3.德才分dc都低于H线，但德分d高于才分c，排在第二类后面
    //4.其他高于L线的按总分排序，排在第三类后面
    //注：总分若相同按德分d降序排序，若德分相同则按准考证升序输出（准考号小的排前面）
    public static void main(String[] args) throws IOException {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        String[] s = br.readLine().split(" ");
        int n = Integer.parseInt(String.valueOf(s[0]));
        int l = Integer.parseInt(String.valueOf(s[1]));
        int h = Integer.parseInt(String.valueOf(s[2]));
        ArrayList<Achievement> l1 = new ArrayList<>();
        ArrayList<Achievement> l2 = new ArrayList<>();
        ArrayList<Achievement> l3 = new ArrayList<>();
        ArrayList<Achievement> l4 = new ArrayList<>();
        for (int i = 0 ; i <n ; i++) {
            String[] str = br.readLine().split(" ");
            int admission = Integer.parseInt(String.valueOf(str[0]));
            int m = Integer.parseInt(String.valueOf(str[1]));
            int abi = Integer.parseInt(String.valueOf(str[2]));
            if (m >= l && abi >=l){
                if (m >= h && abi >=h){
                    l1.add(new Achievement(m,abi,admission));
                }else if( m >= h && abi < h){
                    l2.add(new Achievement(m,abi,admission));
                }else if (m < h && abi < h && m > abi){
                    l3.add(new Achievement(m,abi,admission));
                }else {
                    l4.add(new Achievement(m,abi,admission));
                }
            }
        }
        Collections.sort(l1,new AchievementCompare());
        Collections.sort(l2,new AchievementCompare());
        Collections.sort(l3,new AchievementCompare());
        Collections.sort(l4,new AchievementCompare());
        List<List<Achievement>>sumList=new ArrayList<>();
        sumList.add(l1);
        sumList.add(l2);
        sumList.add(l3);
        sumList.add(l4);
        System.out.println(l1.size()+l2.size()+l3.size()+l4.size());
        for (int i = 0; i <sumList.size() ; i++) {
            List<Achievement> curList=sumList.get(i);
            for (int j = 0; j <curList.size() ; j++) {
                Achievement a=(Achievement) curList.get(j);
                System.out.println(a.admission+" "+a.moralA+" "+a.abilityA);
            }
        }
    }
}
class Achievement {
    int moralA;
    int abilityA;
    int admission;
    public Achievement(int m,int abi,int admission){
        super();
        this.moralA = m;
        this.abilityA = abi;
        this.admission = admission;
    }
}

class AchievementCompare implements Comparator<Achievement>{
    public int compare(Achievement a1,Achievement a2) {
        int a1sum = a1.moralA+a1.abilityA;//总分
        int a2sum = a2.moralA+a2.abilityA;
        int x=a2sum-a1sum;
        int y=a2.moralA-a1.moralA;
        int z=a1.admission-a2.admission;
        if(x==0){
            if(y==0)
                return z;
            else
                return y;
        }
        return x;
    }
}
```

