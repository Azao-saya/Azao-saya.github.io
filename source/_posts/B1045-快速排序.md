---
title: B1045-快速排序
date: 2019-11-2 5:34:12 
categories: PAT练习
tags:
- 未AC题目
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/id=69606244.rzhzf5abaxs.png
---

## 题目描述 <!--more-->

-  著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 *N* 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？

  例如给定 $N = 5$, 排列是1、3、2、4、5。则：

  - 1 的左边没有元素，右边的元素都比它大，所以它可能是主元；
  - 尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元；
  - 尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元；
  - 类似原因，4 和 5 都可能是主元。

  因此，有 3 个元素可能是主元。

## 输入描述

>输入在第 1 行中给出一个正整数 *N*（≤105）； 第 2 行是空格分隔的 *N* 个不同的正整数，每个数不超过 109。 

## 输出描述:

>在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。 

## 示例

### 输入

> 5
> 1 3 2 4 5

### 输出

> 3
> 1 4 5

## 解题思路：

-  主元的定位为左边都比他小，右边都比他大。
-  先定义一个计数器，和一个存放主元的数组
-  假设数为主元，设置一个flag为true。如果其满足主元的定义，他会在循环里一直continue，不进行flag = false的赋值。
-  最后在输出结果

---

---



```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;

public class PAT_B1045 {
    public static void main(String[] args) throws IOException {//就这样了这题没有java解法，优化的话最多再通过一个测试点
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        String[] temp =br.readLine().split(" ");
        int[] numbers = new int[n];
        for (int i = 0; i < n ; i++) {
            numbers[i] = Integer.parseInt(temp[i]);
        }
        int count = 0;
        ArrayList<Integer> index = new ArrayList<>();
        for (int i = 0; i < n ; i++) {
            int majorNum = numbers[i];
            boolean flag = true;
            for (int j = 0; j <n ; j++) {
                if (j==i){
                    continue;
                }else if(j<i && numbers[j]<majorNum){
                    continue;
                }else if (j>i && numbers[j]>majorNum){
                    continue;
                }
                flag = false;
                break;
            }
            if (flag){
                count++;
                index.add(majorNum);
            }
        }
        System.out.println(count);
        for (int i = 0; i <index.size()-1 ; i++) {
            System.out.print(index.get(i)+" ");
        }
        System.out.print(index.get(index.size()-1));
    }
}
```

