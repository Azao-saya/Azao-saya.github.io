---
title: B1035-插入与归并
date: 2019-11-1 9:34:12 
categories: PAT练习
tags: 
- sort
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/id=66095083.46m18zruic60.png
---

## 题目描述 <!--more-->

-   根据维基百科的定义：

  **插入排序**是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。

  **归并排序**进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。

  现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？ 

## 输入描述

>      输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。  

## 输出描述:

>     首先在第 1 行中输出`Insertion Sort`表示插入排序、或`Merge Sort`表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。 

## 示例

### 输入1

> 10
> 3 1 2 8 7 5 9 4 6 0
> 1 2 3 7 8 5 9 4 6 0

### 输出1

> Insertion Sort
> 1 2 3 5 7 8 9 4 6 0

### 输入2

> 10
> 3 1 2 8 7 5 9 4 0 6
> 1 3 2 8 5 7 4 9 0 6

### 输出2

> Merge Sort
> 1 2 3 8 4 5 7 9 0 6

## 解题思路：

-   真滴看不懂
-  (![img](https://s2.ax1x.com/2019/11/25/MXDJPI.gif) )
-  不应该这样么
-  好吧重新读了之后懂了只再迭代了一轮
-  判断插入排序还是归并排序是条件是
-  插入排序排序到中间序列时，在那一个结束升序之后的数字应该都是和原始数列是相同的
-  插入排序在对i+1位数进行排序就直接输出，
-  归并排序在数组等于题目给出的中间序列之后在进行一次归并操作，k乘2能自己再迭代 (读懂也不会写.....

-----

-----

```
import java.util.Arrays;
import java.util.Scanner;
public class PAT_B1035 {

    public static void main(String[] args) throws Exception { //代码转载自熊仙森
        Scanner inScanner = new Scanner(System.in);
        int n =inScanner.nextInt();
        int [] a =new int[n];
        int [] b =new int[n];
        for(int i=0;i<n;i++)
            a[i]=inScanner.nextInt();
        for(int i=0;i<n;i++)
            b[i]=inScanner.nextInt();
        inScanner.close();

        int i = 0;
        //判断排好序的位置
        for (; b[i] <= b[i + 1] && i < n; i++);
        boolean isInsert = true;
        for (int j = i + 1; j < n; j++) {
            //判断排好序的位置的后面开始，a与b是不是每一位都相同，若出现不相同，则不是插入排序
            if (a[j] != b[j]) {
                isInsert = false;
                break;
            }
        }
        if (isInsert) {
            System.out.println("Insertion Sort");
            //再加一个数字进行排序
            sort(a, 0, i + 1);
        } else {
            System.out.println("Merge Sort");
            //从a开始执行归并排序，当与b一样时，再执行一次
            int k = 1;
            boolean flag = false;
            while (flag == false) {
                //当a==b时，再执行一次，下一次判断时跳出
                flag = Arrays.equals(a, b);
                k = k * 2;
                int p = 0;
                for (p = 0; p < n / k; p++)
                    //p是分成的一个一个小组，k是每个组的成员个数
                    //一组的起始是p * k，结束是下一组的开始位置减一
                    sort(a, p * k, (p + 1) * k - 1);
                //分完组后剩下的不够的做一次分组内的归并
                //开始是 n / k * k（组数*长度），结束是到数组的最后
                sort(a, n / k * k, n - 1);
            }
        }
        for (int k = 0; k < n ; k++) {
            if(k!=0)
                System.out.print(" ");
            System.out.print(a[k]);
        }
    }
    //自定义交换排序，也可用Arrays.sort，但是位置限制有点麻烦
    public static void sort(int[] a, int from, int to) {
        for (int i = from; i < to; i++) {
            for (int j = i + 1; j <= to; j++) {
                if (a[j] < a[i]) {
                    int temp = a[i];
                    a[i] = a[j];
                    a[j] = temp;
                }
            }
        }
    }
}
```

