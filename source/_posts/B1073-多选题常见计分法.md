---
title: B1073-多选题常见计分法
date: 2019-11-9 7:34:12 
categories: PAT练习
tags: 
- HashMap
- 祖传屎山代码
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/id=55325876(loundraw).78z228rx71o0.jpg
---

## 题目描述 <!--more-->

 批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。 

## 输入描述

>      输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 `(选中的选项个数 选项1 ……)`，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。 

## 输出描述:

>     按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：`错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号`。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 `Too simple`。 

### 输入1

> 3 4 
> 3 4 2 a c
> 2 5 1 b
> 5 3 2 b c
> 1 5 4 a b d e
> (2 a c) (3 b d e) (2 a c) (3 a b e)
> (2 a c) (1 b) (2 a b) (4 a b d e)
> (2 b d) (1 e) (1 c) (4 a b c d)

### 输出1

> 3.5
> 6.0
> 2.5
> 2 2-e
> 2 3-a
> 2 3-b

### 输入2

> 2 2 
> 3 4 2 a c
> 2 5 1 b
> (2 a c) (1 b)
> (2 a c) (1 b)

### 输出2

> 5.0
> 5.0
> Too simple

## 解题思路：

- 正确答案是bc，如果解答是c。是算b错误。
- 硬写出来的没啥思路

---

---



```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class PAT_B1073 {
    public static void main(String[] args) throws IOException { //最后一个测试点超时，23点想再做一题睡觉，结果4点了
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] temp = br.readLine().split(" ");
        int n = Integer.parseInt(temp[0]);
        int m = Integer.parseInt(temp[1]);
        double[] fullSocre = new double[m];
//        int[] wrongs = new int[m];
        String[] right = new String[m];
        double[] studentS =new double[n];
//        String[] matter = new String[m];
        Map<String,Integer> map = new HashMap<>();
        List<String> output=new ArrayList<String>();
        for (int i = 0; i <m ; i++) {
            String str = br.readLine();
            fullSocre[i] = Integer.parseInt(str.substring(0,1));
            right[i] = str.substring(5).replace(" ","");
        }
        for (int i = 0; i <n ; i++) {
            String str = br.readLine();
            str = str.substring(1,str.length()-1); //str.indexOf('(') + 1, str.lastIndexOf(')')
            String[] s = str.split("\\)\\s*\\(");
            for (int j = 0; j <m ; j++) {
                String w = s[j].replace(" ","").substring(1);
                if (w.equals(right[j])){
                    studentS[i] += fullSocre[j];
                }else {
//                    wrongs[j]++;
                    boolean flag = false;
                    String temp42 = abDeal(w,right[j]);
                    String temp24 = abDeal(right[j],w);
                    if (temp42.length()==0){
                        flag = true;
                    }else if (temp42.length()!=0) {
                        for (int k = 0; k <temp42.length() ; k++) {
                            if (map.containsKey(j+1+"-"+temp42.charAt(k))){
                                map.put(j+1+"-"+temp42.charAt(k),map.get(j+1+"-"+temp42.charAt(k))+1);
                            }else {
                                map.put(j+1+"-"+temp42.charAt(k),1);
                            }
                        }
                    }
                    if (temp24.length()!=0){
                        for (int k = 0; k <temp24.length() ; k++) {
                            if (map.containsKey(j+1+"-"+temp24.charAt(k))){
                                map.put(j+1+"-"+temp24.charAt(k),map.get(j+1+"-"+temp24.charAt(k))+1);
                            }else {
                                map.put(j+1+"-"+temp24.charAt(k),1);
                            }
                        }
                    }
                    if (flag){
                        studentS[i] += fullSocre[j]/2;
                    }
                }
            }
        }
        int max = 0;
        for(Integer value:map.values()) {
            if(value>max) {
                max=value;
            }
        }
        for (double s : studentS) {
            System.out.println(s);
        }
        if(max==0) {
            System.out.println("Too simple");
        }else {
            for(Map.Entry<String, Integer> entry:map.entrySet()) {
                if(entry.getValue()==max) {
                    output.add(entry.getValue()+" "+entry.getKey());
                }
            }
        }
        Collections.sort(output);
        for(int i=0;i<output.size();i++) {
            System.out.println(output.get(i));
        }
    }

    public static String abDeal(String a,String b) {
        String str="";
        for(int i=0;i<a.length();i++) {
            int flag=0;
            for(int j=0;j<b.length();j++) {
                if(b.charAt(j)==a.charAt(i)) {
                    flag=1;
                }
            }
            if(flag==0) {
                str+=a.charAt(i);
            }
        }
        return str;
    }
}
```

