---
title: 牛客网《数据库SQL实战》练习21-30
date: 2020-6-21 5:34:12 
categories: 云笔记
tags:
- MySql
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/61ec1619gy1g0mbfhhm7pj21c00lqwid_看图王.63pc0rpy2uo0.jpg
---

## 21.获取所有员工当前的manager<!--more-->

**题目描述：**

查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_no以及其对应的薪水涨幅growth，并按照growth进行升序

（注:可能有employees表和salaries表里存在记录的员工，有对应的员工编号和涨薪记录，但是已经离职了，离职的员工salaries表的最新的to_date!='9999-01-01'，这样的数据不显示在查找结果里面）

CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL, -- '入职时间'
PRIMARY KEY (`emp_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL, -- '一条薪水记录开始时间'
`to_date` date NOT NULL, -- '一条薪水记录结束时间'
PRIMARY KEY (`emp_no`,`from_date`));

**输入描述:**

无

**输出描述:**

| emp_no | growth |
| :----: | :----: |
| 10011  |   0    |
|  省略  |  省略  |
| 10010  | 54496  |
| 10004  | 34003  |

**解题代码：**

> select a.emp_no, (b.salary - c.salary) as growth
> from
>     employees as a
>     inner join salaries as b
>     on a.emp_no = b.emp_no and b.to_date = '9999-01-01'
>     inner join salaries as c
>     on a.emp_no = c.emp_no and a.hire_date = c.from_date
> order by growth asc

**吐槽：**

>没做出来
>
>离职员工是to_date !='9999-01-01'的员工，刚开始没注意到！,如果真是=难度就高很多了(都一样)
>
>在题目描述里说明了`to_date` 是一条薪水记录结束时间，而‘9999-01-01’又是最新的记录。
>
>所以如果条件为to_date = '9999-01-01'进行搜索可以得到员工的最终工资
>
>若`from_date`=`hire_date`可以得到最初的工资
>
>按两个不同的条件筛选同一张表后连接，最后得到order by growth asc得到升序结果

## 22.统计各个部门的工资记录数

**题目描述：**

统计各个部门的工资记录数，给出部门编码dept_no、部门名称dept_name以及部门在salaries表里面有多少条记录sum
CREATE TABLE `departments` (
`dept_no` char(4) NOT NULL,
`dept_name` varchar(40) NOT NULL,
PRIMARY KEY (`dept_no`));
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

**输入描述:**

无

**输出描述:**

| dept_no |      dept_name       | sum  |
| :-----: | :------------------: | ---- |
|  d001   |      Marketing0      | 24   |
|  d002   |     Finance省略      | 14   |
|  d003   | Human Resources54496 | 13   |
|  d004   |   Production34003    | 24   |
|  d005   |     Development      | 25   |
|  d006   |  Quality Management  | 25   |

**解题代码：**

> select de.dept_no,dp.dept_name,count(s.salary) as sum
> from salaries as s 
> inner join dept_emp as de on de.emp_no = s.emp_no
> inner join departments AS dp ON de.dept_no = dp.dept_no
> group by de.dept_no

**吐槽：**

>题目提到了sum自然想用sum()来做了，用了才发现不是一回事
>
>sum()是返回每个列里数值相加之后的总和，而题目只需要知道有多少条数目就行了
>
>因为是用 inner join 连接改变顺序也不影响结果

## 23.对所有员工的薪水按照salary进行按照1-N的排名

**题目描述：**

对所有员工的当前(to_date='9999-01-01')薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

**输入描述:**

无

**输出描述:**

| emp_no | salary | rank |
| :----: | :----: | :--: |
| 10005  | 94692  |  1   |
| 10009  | 94409  |  2   |
| 10010  | 94409  |  2   |
| 10001  | 88958  |  3   |
| 10007  | 88070  |  4   |
| 10004  | 74057  |  5   |

**解题代码：**

> 1>
>
> SELECT s1.emp_no, s1.salary, COUNT(DISTINCT s2.salary) AS rank
> FROM salaries AS s1, salaries AS s2
> WHERE s1.to_date = '9999-01-01'  AND s2.to_date = '9999-01-01' AND s1.salary <= s2.salary
> GROUP BY s1.emp_no
> ORDER BY s1.salary DESC, s1.emp_no ASC
>
> 2>
>
> select emp_no,salary,dense_rank() over(order by salary desc) as rank
> from salaries 
>  where to_date='9999-01-01'
>  order by rank,emp_no;

**吐槽：**

>复用同表，没做出。第二种使用了窗口函数8.0以上才可用，只记下了。
>
>关于其中的s1.salary <= s2.salary 也是没整明白，别人写了个总结顺便也就贴了上来。
>
>链接：https://www.nowcoder.com/questionTerminal/b9068bfe5df74276bd015b9729eec4bf?f=discussion
>来源：牛客网
>
>第一轮：
>s1.1 <= s2.1; 成立 则，s1=[1] s2=[1]
>s1.2 <= s2.1; 不成立，s1,s2不增加元素
>s1.3 <= s2.1; 不成立，s1,s2不增加元素
>
>第二轮：
>s1.1 <= s2.2; 成立 s1=[1,1] s2=[1,2]
>s1.2 <= s2.2; 成立 s1=[1,1,2] s2=[1,2,2]
>s1.3 <= s2.2; 不成立，s1,s2不增加元素
>
>第三轮：
>s1.1 <= s2.3; 成立 s1=[1,1,2，1] s2=[1,2,2,3]
>s1.2 <= s2.3; 成立 s1=[1,1,2，1，2] s2=[1,2,2,3，3]
>s1.3 <= s2.3; 成立 s1=[1,1,2，1，2，3] s2=[1,2,2,3，3,3]
>
>1、每一轮，左表的每一个元素都和右表的一个元素比较
>
>2、如果等式成立，则左表元素被添加进s1，右表元素添加进s2
>
>3、所以可以看到s1的值呈“交替”出现，而s2的值是“扎堆出现”
>
>又查了一下知道了这个是笛卡尔乘积
>
>假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。

## 24.获取所有非manager员工当前的薪水情况

**题目描述：**

获取所有非manager员工当前的薪水情况，给出dept_no、emp_no以及salary ，当前表示to_date='9999-01-01'
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,
PRIMARY KEY (`emp_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

**输入描述:**

无

**输出描述:**

| dept_no | emp_no | salary |
| :-----: | :----: | :----: |
|  d001   | 10001  | 88958  |
|  d004   | 10003  | 43311  |
|  d005   | 10007  | 88070  |
|  d006   | 10009  | 95409  |

**解题代码：**

> 1>
>
> select de.dept_no,e.emp_no,s.salary
> from dept_emp as de inner join employees as e
> on e.emp_no = de.emp_no
> inner join salaries as s on e.emp_no= s.emp_no
> where de.to_date = '9999-01-01' and s.to_date = '9999-01-01'
> and de.emp_no not in (SELECT emp_no FROM dept_manager WHERE to_date = '9999-01-01')
>
> 2>
>
> SELECT de.dept_no, s.emp_no, s.salary 
> FROM dept_emp AS de INNER JOIN salaries AS s ON s.emp_no = de.emp_no AND s.to_date = '9999-01-01'
> WHERE de.emp_no NOT IN (SELECT emp_no FROM dept_manager WHERE to_date = '9999-01-01')

**吐槽：**

>把题目要求的一个一个添加上去就行
>
>第二种方法进一步简化了，没有连接employees表

## 25.获取员工其当前的薪水比其manager当前薪水还高的相关信息

**题目描述：**

获取员工其当前的薪水比其manager当前薪水还高的相关信息，当前表示to_date='9999-01-01',
结果第一列给出员工的emp_no，
第二列给出其manager的manager_no，
第三列给出该员工当前的薪水emp_salary,
第四列给该员工对应的manager当前的薪水manager_salary
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL,
`emp_no` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

**输入描述:**

无

**输出描述:**

| emp_no | manager_no | emp_salary | manager_salary |
| :----: | :--------: | :--------: | -------------- |
| 10001  |   10002    |   88958    | 72527          |
| 10009  |   10010    |   95409    | 94409          |

**解题代码：**

> 1>
>
> select x.emp_no ,
> y.emp_no as manager_no,
> x.salary as emp_salary,
> y.salary as manager_salary
> from(select s.emp_no,s.salary,de.dept_no 
> 	from salaries as s inner join dept_emp as de 
> 	on s.emp_no = de.emp_no and s.to_date='9999-01-01' ) as x,
> (select s.emp_no,s.salary,dm.dept_no 
> 	from salaries as s inner join dept_manager as dm 
> 	on s.emp_no = dm.emp_no and s.to_date='9999-01-01') as y
> where x.dept_no = y.dept_no and x.salary > y.salary
>
> 2>
>
>SELECT de.emp_no,dm.emp_no manager_no,
> sa.salary emp_salary,sal.salary manager_salary
> FROM dept_emp de,salaries sa,dept_manager dm,salaries sal
> WHERE de.emp_no=sa.emp_no
> AND dm.emp_no=sal.emp_no
> AND de.dept_no=dm.dept_no
> AND de.to_date='9999-01-01'
> AND sa.to_date='9999-01-01'
> AND dm.to_date='9999-01-01'
> AND sal.to_date='9999-01-01'
> AND sa.salary>sal.salary

**吐槽：**

>语句比较长，做出来之后还花了一段时间检查哪里手抖了。
>
>两种解法用的一个方法，就是先查出经理的编号和薪水，再找出员工的编号和薪水，
>
>最后进行对比，输出所的内容。

## 26.汇总各个部门当前员工的title类型的分配数目

**题目描述：**

汇总各个部门当前员工的title类型的分配数目，即结果给出部门编号dept_no、dept_name、其部门下所有的当前(dept_emp.to_date = '9999-01-01')员工的当前(titles.to_date = '9999-01-01')title以及该类型title对应的数目count

(注：因为员工可能有离职，所有dept_emp里面to_date不为'9999-01-01'就已经离职了，不计入统计，而且员工可能有晋升，所以如果titles.to_date 不为 '9999-01-01'，那么这个可能是员工之前的职位信息，也不计入统计)

CREATE TABLE `departments` (
`dept_no` char(4) NOT NULL,
`dept_name` varchar(40) NOT NULL,
PRIMARY KEY (`dept_no`));
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE IF NOT EXISTS `titles` (
`emp_no` int(11) NOT NULL,
`title` varchar(50) NOT NULL,
`from_date` date NOT NULL,
`to_date` date DEFAULT NULL);

**输入描述:**

无

**输出描述:**

| dept_no |     dept_name      |        title         | count |
| :-----: | :----------------: | :------------------: | ----- |
|  d001   |   Marketing10002   | Senior Engineer88958 | 1     |
|  d001   |   Marketing10010   |      Staff95409      | 1     |
|  d002   |      Finance       |   Senior Engineer    | 1     |
|  d003   |  Human Resources   |     Senior Staff     | 1     |
|  d004   |     Production     |   Senior Engineer    | 2     |
|  d005   |    Development     |     Senior Staff     | 1     |
|  d006   | Quality Management |       Engineer       | 2     |
|  d006   | Quality Management |   Senior Engineer    | 1     |

**解题代码：**

> 1>
>
> select de.dept_no,dp.dept_name,t.title,count(t.title) as count 
> from departments as dp inner join dept_emp as de
> on dp.dept_no = de.dept_no and de.to_date ='9999-01-01'
> inner join titles as t on de.emp_no = t.emp_no
> and t.to_date = '9999-01-01'
> group by de.dept_no,t.title

**吐槽：**

>group by 用逗号连接了两个数据，效果为任意一个数据不同时另开一个分组。
>
>但是最开始我用了group by t.title ,de.dept_no，仅仅调换顺序就无法通过OJ
>
>网友给的解释是：“各个部门当前员工的title类型的分配数目”，首先是各个部门，按照部门分组。然后在此基础上，“员工的title类型”，所以再title
>
>虽然在本地用有限的数据用例里调换顺序对结果没影响，网上也没找到相关的解释

## 27.给出每个员工每年薪水涨幅超过5000的员工编号emp_no

**题目描述：**

给出每个员工每年薪水涨幅超过5000的员工编号emp_no、薪水变更开始日期from_date以及薪水涨幅值salary_growth，并按照salary_growth逆序排列。

提示：在sqlite中获取datetime时间对应的年份函数为strftime('%Y', to_date)

(数据保证每个员工的每条薪水记录to_date-from_date=1年，而且同一员工的下一条薪水记录from_data=上一条薪水记录的to_data)


CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,

PRIMARY KEY (`emp_no`,`from_date`));

**输入描述:**

无

**输出描述:**

| emp_no | from_date  | salary_growth |
| :----: | :--------: | :-----------: |
| 10001  | 1987-06-26 |     9985      |

**解题代码：**

> 1>
>
> SElECT s2.emp_no,s2.from_date,(s2.salary - s1.salary) AS salary_growth
> FROM salaries AS s1, salaries AS s2
> WHERE s1.emp_no = s2.emp_no
> AND salary_growth > 5000
> AND strftime("%Y",s2.to_date) - strftime("%Y",s1.to_date) = 1
> ORDER BY salary_growth DESC

**吐槽：**

>拼写错误又找了好久的问题。
>
>下面是strftime()一些补充
>
>%d 日期, 01-31
>%f 小数形式的秒，SS.SSS
>%H 小时, 00-23
>%j 算出某一天是该年的第几天，001-366
>%m 月份，00-12
>%M 分钟, 00-59
>%s 从1970年1月1日到现在的秒数
>%S 秒, 00-59
>%w 星期, 0-6 (0是星期天)
>%W 算出某一天属于该年的第几周, 01-53
>%Y 年, YYYY
>%% 百分号

## 28.查找描述信息中包含robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量>=5部

**题目描述：**

> film表
>
> | 字段        | 说明         |
> | ----------- | ------------ |
> | film_id     | 电影id       |
> | title       | 电影名称     |
> | description | 电影描述信息 |
>
> 
>
> > CREATE TABLE IF NOT EXISTS film (
> >
> > film_id smallint(5)  NOT NULL DEFAULT '0',
> >
> > title varchar(255) NOT NULL,
> >
> > description text,
> >
> > PRIMARY KEY (film_id));
>
> category表
>
> | 字段        | 说明                 |
> | ----------- | -------------------- |
> | category_id | 电影分类id           |
> | name        | 电影分类名称         |
> | last_update | 电影分类最后更新时间 |
>
> 
>
> > CREATE TABLE category  (
> >
> > category_id  tinyint(3)  NOT NULL ,
> >
> > name  varchar(25) NOT NULL, `last_update` timestamp,
> >
> > PRIMARY KEY ( category_id ));
>
> film_category表
>
> | 字段        | 说明                                 |
> | ----------- | ------------------------------------ |
> | film_id     | 电影id                               |
> | category_id | 电影分类id                           |
> | last_update | 电影id和分类id对应关系的最后更新时间 |
>
> 
>
> > CREATE TABLE film_category  (
> >
> > film_id  smallint(5)  NOT NULL,
> >
> > category_id  tinyint(3)  NOT NULL, `last_update` timestamp);
>
> 查找描述信息(film.description)中包含robot的电影对应的分类名称(category.name)以及电影数目(count(film.film_id))，而且还需要该分类包含电影总数量(count(film_category.category_id))>=5部



无

**输出描述:**

| 分类名称category.name | 电影数目count(film.film_id) |
| :-------------------: | :-------------------------: |
|      Documentary      |              1              |

**解题代码：**

> 1>
>
> SELECT c.name, COUNT(fc.film_id) FROM
>  (select category_id FROM
>      	film_category  
> 		 GROUP BY category_id HAVING count(*)>=5 ) 
>
> ​	AS temp,
> ​    film AS f,
> ​	film_category AS fc, 
> ​	category AS c
> WHERE  f.description LIKE '%robot%'
> AND f.film_id = fc.film_id
> AND c.category_id = fc.category_id
> AND c.category_id=temp.category_id

**吐槽：**

>这里开始换了一个出题方式，虽然给的信息非常多，但没太把东西讲清楚。最后的题目描述里预设了太多语句甚至在输出内容里面都加了注释（里面应该输出的最终结果），非常很影响理解题目，花了很长时间适应，如果接下来都是这样的出题方式的话我打算放弃后面的题目。
>
>首先，该分类包含电影总数量(count(film_category.category_id))>=5部
>
>在film_category中聚合函数分组，且一个组中需要至少5个数据才会被统计，作为一个表
>
>随后在连接依次重新连接三个表
>
>使用like匹配通配符指定模式的文本值，%表示任意个字符或数字，前后都加上%意为查找任意位置包含robot的任意值
>
>最后加上限制从题目要求中category表提出name
>
>电影数目count(film.film_id)下的1也说明了，大于5部并不是用在这里。

## 29.使用join查询方式找出没有分类的电影id以及名称

**题目描述：**

> film表
>
> | 字段        | 说明         |
> | ----------- | ------------ |
> | film_id     | 电影id       |
> | title       | 电影名称     |
> | description | 电影描述信息 |
>
> 
>
> > CREATE TABLE IF NOT EXISTS film (
> >
> > film_id smallint(5)  NOT NULL DEFAULT '0',
> >
> > title varchar(255) NOT NULL,
> >
> > description text,
> >
> > PRIMARY KEY (film_id));
>
> category表
>
> | 字段        | 说明                 |
> | ----------- | -------------------- |
> | category_id | 电影分类id           |
> | name        | 电影分类名称         |
> | last_update | 电影分类最后更新时间 |
>
> 
>
> > CREATE TABLE category  (
> >
> > category_id  tinyint(3)  NOT NULL ,
> >
> > name  varchar(25) NOT NULL, `last_update` timestamp,
> >
> > PRIMARY KEY ( category_id ));
>
> film_category表
>
> | 字段        | 说明                                 |
> | ----------- | ------------------------------------ |
> | film_id     | 电影id                               |
> | category_id | 电影分类id                           |
> | last_update | 电影id和分类id对应关系的最后更新时间 |
>
> 
>
> > CREATE TABLE film_category  (
> >
> > film_id  smallint(5)  NOT NULL,
> >
> > category_id  tinyint(3)  NOT NULL, `last_update` timestamp);
>
> 
>
> 使用join查询方式找出没有分类的电影id以及名称



无

**输出描述:**

| 电影id |       名称       |
| :----: | :--------------: |
|   3    | ADAPTATION HOLES |

**解题代码：**

> 1>
>
> SELECT f.film_id ,f.title
> FROM film AS f LEFT JOIN film_category AS fc
> ON f.film_id = fc.film_id 
> WHERE fc.category_id IS NULL

**吐槽：**

>这里再明确一下on和where，之前其实这两个其实想到哪个就用哪个的，错了再换。
>
>`ON` 是建立关联关系，`WHERE` 是对关联关系的筛选
>
>在使用`left jion` 时
>
>`on` 条件是在生成临时表时使用的条件，它不管 `on` 中的条件是否为真，都会返回左边表中的记录。
>
>`where` 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 `left join` 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。
>
>使用on才能接受到null
>
>如果不是题目要求用join 的话not in也能完成这题，这样也能通过oj
>
>select film_id, title from film
>where film_id not in (select film_id from film_category)

## 30.使用join查询方式找出没有分类的电影id以及名称

**题目描述：**

> film表
>
> | 字段        | 说明         |
> | ----------- | ------------ |
> | film_id     | 电影id       |
> | title       | 电影名称     |
> | description | 电影描述信息 |
>
> 
>
> > CREATE TABLE IF NOT EXISTS film (
> >
> > film_id smallint(5)  NOT NULL DEFAULT '0',
> >
> > title varchar(255) NOT NULL,
> >
> > description text,
> >
> > PRIMARY KEY (film_id));
>
> category表
>
> | 字段        | 说明                 |
> | ----------- | -------------------- |
> | category_id | 电影分类id           |
> | name        | 电影分类名称         |
> | last_update | 电影分类最后更新时间 |
>
> 
>
> > CREATE TABLE category  (
> >
> > category_id  tinyint(3)  NOT NULL ,
> >
> > name  varchar(25) NOT NULL, `last_update` timestamp,
> >
> > PRIMARY KEY ( category_id ));
>
> film_category表
>
> | 字段        | 说明                                 |
> | ----------- | ------------------------------------ |
> | film_id     | 电影id                               |
> | category_id | 电影分类id                           |
> | last_update | 电影id和分类id对应关系的最后更新时间 |
>
> 
>
> > CREATE TABLE film_category  (
> >
> > film_id  smallint(5)  NOT NULL,
> >
> > category_id  tinyint(3)  NOT NULL, `last_update` timestamp);
>
> 你能使用子查询的方式找出属于Action分类的所有电影对应的title,description吗



无

**输出描述:**

|      title       |                         description                          |
| :--------------: | :----------------------------------------------------------: |
| ACADEMY DINOSAUR | A Epic Drama of a Feminist And a Mad Scientist who must Battle a Teacher in The Canadian RockiesADAPTATION HOLES |
|  ACE GOLDFINGER  | A Astounding Epistle of a Database Administrator And a Explorer who must Find a Car in Ancient China |

**解题代码：**

> 1>
>
> SELECT f.title,f.description
> FROM film as f 
> WHERE f.film_id IN 
> 	(SELECT fc.film_id 
> 			FROM film_category as fc
> 			WHERE fc.category_id IN 
> 				(SELECT c.category_id FROM category as c
> 							WHERE c.name = 'Action')
> 	)

**吐槽：**

>子查询就是在查询中嵌套小查询，这样的话确实很早之前就在使用了，不过这次稍许有点不一样又多嵌套了一层。
>
>此次查询中可以不用另外命名
>
>最后WHERE c.name = 'Action' 按照上题的习惯我最初用的是like，但是又出现了手抖错误，检查的时候便改成等于。排除错误之后，like在此使用确实也是正确的。

