---
title: B1090-危险品装箱
date: 2019-12-3 1:34:12 
categories: PAT练习
tags:
- 未AC题目
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/5.id=75992949.67ub5prkgnc0.png
---

## 题目描述 <!--more-->

集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。

本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。

## 输入描述

>  输入第一行给出两个正整数：*N* (≤104) 是成对的不相容物品的对数；*M* (≤100) 是集装箱货品清单的单数。
>
>  随后数据分两大块给出。第一块有 *N* 行，每行给出一对不相容的物品。第二块有 *M* 行，每行给出一箱货物的清单，格式如下：
>
>  ```
>  K G[1] G[2] ... G[K]
>  ```
>
>  其中 `K` (≤1000) 是物品件数，`G[i]` 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。

## 输出描述

>   对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 `Yes`，否则输出 `No`。 

## 示例

### 输入

> 6 3
> 20001 20002
> 20003 20004
> 20005 20006
> 20003 20001
> 20005 20004
> 20004 20006
> 4 00001 20004 00002 20003
> 5 98823 20002 20003 20006 10010
> 3 12345 67890 23333

### 输出

> No
> Yes
> Yes

## 解题思路：

- 前面一顿操作是为了达到一个键存储多个的值的效果。
- 如果map里存储这个键，代表该物品有不能与其相容的其他物品。
- 就取出值比对所有要检查的物品。值里有多个物品要检查的物品也有多个。加一层循环。

---

---



```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;

public class PAT_B1090 {
    public static void main(String[] args) throws IOException { //最后一个测试点超时
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] temp  = br.readLine().split(" ");
        int n = Integer.parseInt(temp[0]);
        int m = Integer.parseInt(temp[1]);
        HashMap<String,String> map = new HashMap<>();
        for (int i = 0; i <n ; i++) {
            String[] temp2 = br.readLine().split(" ");
            String a = temp2[0];
            String b = temp2[1];
            String str;
            if(map.containsKey(a)&&map.containsKey(b)) {
                str=map.get(a);
                map.put(a, str+" "+b);
                str=map.get(b);
                map.put(b, str+" "+a);
            }else if(!map.containsKey(a)&&map.containsKey(b)){
                map.put(a, b);
                str=map.get(b);
                map.put(b, str+" "+a);
            }else if(map.containsKey(a)&&!map.containsKey(b)) {
                str=map.get(a);
                map.put(a, str+" "+b);
                map.put(b, a);
            }else if(!map.containsKey(a)&&!map.containsKey(b)){
                map.put(a, b);
                map.put(b, a);
            }
        }
//        for(Map.Entry<String, String> entry : map.entrySet()){
//            String mapKey = entry.getKey();
//            String mapValue = entry.getValue();
//            System.out.println(mapKey+":"+mapValue);
//        }
        for (int i = 0; i < m ; i++) {
            String[] temp3 = br.readLine().split(" ");
            int size = Integer.parseInt(temp3[0]);
            boolean flag = true;
            loop:for (int j = 1; j <=size ; j++) {
                if (!map.containsKey(temp3[j])){
                    continue ;
                }
                for (int k = 1; k <=size ; k++) {
                    String[] value = map.get(temp3[j]).split(" ");
                    for (int l = 0; l <value.length ; l++) {
                        if (temp3[k].equals(value[0])){
                            System.out.println("No");
                            flag = false;
                            break loop;
                        }
                    }
                }
            }
            if (flag){
                System.out.println("Yes");
            }
        }
    }
}
```

