---
title: B1048-数字加密
date: 2019-11-2 7:40:12 
categories: PAT练习
tags:
- stack数组
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/id=69606244.rzhzf5abaxs.png
---

## 题目描述 <!--more-->

-     本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。 

## 输入描述

>输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。 

## 输出描述:

>在一行中输出加密后的结果。 

## 示例

### 输入

> 1234567 368782971

### 输出

> 3695Q8118

## 解题思路：

-  因为从后往前计算奇偶，第一位为奇
-  左边的第一位无法判断奇偶性，这里用栈Stack实现后进先出
-   用 B 的数字减去 A 的数字，若结果为负数，则再加 10。 处理这条时
-  对每一个数加上10在取余10，实现负数+10
-  遍历栈或者说清空栈用while (!stack.isEmpty()) {}

---

---



```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

public class PAT_B1048 {
    public static void main(String[] args) throws IOException { //从后往前计算奇偶，第一位为奇
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] temp = br.readLine().split(" ");
        String strA =temp[0];
        String strB =temp[1];

        int n = strA.length() ;
        int m = strB.length();

        if (n > m) {
            int c = n - m;
            while (c != 0) {
                strB = "0" + strB;
                c--;
            }
        } else if (n < m) {
            int c = m - n;
            while (c != 0) {
                strA = "0" + strA;
                c--;
            }
        }
        int max = strA.length();
        System.out.println(strA);
        System.out.println(strB);
        boolean isEven = false;
        Stack<String> stack = new Stack<>(); //实现了一个标准的后进先出的栈。逆序输出
        for (int i = max-1; i >=0 ; i--) {
            if (isEven){
                isEven = false;
                int c = (strB.charAt(i) - strA.charAt(i)+10)%10 ; //处理负数
                stack.push(c+"");
            }else {
                isEven = true;
                int c = (strA.charAt(i) -'0'+ strB.charAt(i)-'0');
                String s = null;
                switch (c){
                    case 10:
                        s = "J";
                        break;
                    case 11:
                        s = "Q";
                        break;
                    case 12:
                        s = "K";
                        break;
                    default:
                        s = ""+c%13;
                        break;
                }
                stack.push(s);
            }
        }
        while (!stack.isEmpty()) {
            System.out.print(stack.pop()); //出栈，最后被存入的输出
        }
    }
}
```

