---
title: 高斯消元法及约旦消元法
date: 2021/6/3 20:46:25
categories: 折腾
tags:
- 线性代数
cover: /images/c_o_l_a-1533755505226551298-0.jpg
---

实践课被这玩意狠狠滴折磨，还没学过线性代数就提前接触了，不过做都做了还是留下点东西把。

排版中使用了Latex

**高斯消元法和其高斯约旦消元法主要是用来解决n元一次线性方程组**
$$
\left\{
\begin{aligned}
a_1,_1x_1+a_1,_2x_2+ ⋯+a_1,_nx_n=b1  \\
a_2,_1x_1+a_2,_2x_2+ ⋯+a_2,_nx_n=b2 \\
⋮ \qquad⋮ \qquad⋮\qquad⋮\qquad⋮\qquad⋮\qquad⋮\\
a_n,_1x_1+a_n,_2x_2+ ⋯+a_n,_nx_n=bn
\end{aligned}
\right.
$$


两个算法的比较为

**高斯消元法**有回代即把运算的结果回代到式子中代码会相对更多一点，但可以分辨是无解还是无穷解。

**高斯约旦消元法**没有回代，无法区分无解还是无穷解



## 前置芝士

**初等变换**

一般采用消元法来解线性方程组，而消元法实际上是反复对方程进行变换，而所做的变换也只是以下三种基本的变换所构成：

1. 用一非零的数乘以某一方程

2. 把一个方程的倍数加到另一个方程

3. 互换两个方程的位置



简单贴一下高斯消元法算法的方程组最终形式

**高斯消元法**
$$
\left\{
\begin{aligned}
5x+y+6z=25 \\
0x+\frac{13}{5}+\frac{8}{5}z=10\\
0x+0y-\frac{255}{65}z=-\frac{135}{13}\\
\end{aligned}
\right.
$$

最终为**行阶梯型矩阵**即化简为：

1. 如果它既有零行，又有非零行，则零行在下，非零行在上

2. 如果它有非零行，则每个非零行的第一非零元素所在列号自上而下严格单调上升

再进一步可以化简为**行最简形矩阵**即非零行的第一个元素为零，更进一步则是**单位矩阵**，但变换为行阶梯型矩阵已经可以开始回代得出最终解了。

ps1：可能不能用化简这个说法，总之就是线性方程的系数矩阵通过初等行变换得到行阶梯型矩阵，变化矩阵A与矩阵B等价

ps2：在解线性方程组时，把系数矩阵主对角线下方元素消零属于消元；把系数矩阵主对角线上方元素消零属于回代。

回代的过程即③式只剩下z，于是我们可以解出
$$
z=3
$$
然后把z=3代入②式，解得
$$
y = 2
$$
再把它们代入①式，解得
$$
x=1
$$
回代之后在检查无穷解和无解的情况

若存在某方程系数ai,i=0，但bi≠0则为无解，若ai,i=0且bi=0则有无穷解

如果需要判断是无解还是无穷解的话是无法使用更方便的高斯约旦消元法的。

## 高斯-约旦消元法(Gauss-Jordan Elimination)

下面即是这篇文章的核心，以上述方程组为例，具体按照实际代码步骤走
$$
\left\{
\begin{aligned}
3x+2y+z=10 \\
5x+y+6z=25\\
2x+3y+4z=20\\
\end{aligned}
\right.
$$
一列一列处理，首先处理的消元的便是第一列x列，对比我们可以得出5是这一列中最大的，把他作为主元

把①式和②式的位置交换(此举是为了减少消元法时的精度损失直接用3进行消元显然也是可以的)
$$
\left\{
\begin{aligned}
5x+y+6z=25\\
3x+2y+z=10 \\
2x+3y+4z=20\\
\end{aligned}
\right.
$$
首先我们把选出的方程 5x+y+6z=25 的 x 的系数化为 1：
$$
x+\frac{1}{5}y+\frac{6}{5}z=5
$$
然后呢，将它们所在的行减去主元所在的行乘以一定的倍数，具体则是②-①x3，③-①x2，

使得主元所在的列内、 除主元外的其他元素化为 0，这样就使得主元所在的列化为了单位矩阵的形式
$$
\left\{
\begin{aligned}
x+15y+65z=5\\
0x+\frac{13}{5}y+\frac{8}{5}z=10 \\
3x+2y+z=10\\
\end{aligned}
\right.
$$

$$
\left\{
\begin{aligned}
x+15y+65z=5\\
0x+\frac{13}{5}y+\frac{8}{5}z=10 \\
0x+\frac{7}{5}y+(−\frac{13}{5}z)=−5
\end{aligned}
\right.
$$

然后消 y，

在剩下两行内寻找主元，如果说上一轮循环中矩阵a\[i][i] 也就是a\[0][0]是主元的话，这一轮的主元也位于矩阵其主对角线a\[1][1]上，如果不存在同样需要交换位置移动到主对角线上，这里13/5大于7/5就不用换了。
$$
\left\{
\begin{aligned}
x+15y+65z=5\\
0x+y+\frac{8}{13}z=\frac{50}{13} \\
0x+\frac{7}{5}y+(−\frac{13}{5}z)=−5
\end{aligned}
\right.
$$

$$
\left\{
\begin{aligned}
x+0y+\frac{70}{65}z=\frac{275}{65}\\
0x+y+\frac{8}{13}z=\frac{50}{13} \\
0x+\frac{7}{5}y+(−\frac{13}{5}z)=−5
\end{aligned}
\right.
$$

$$
\left\{
\begin{aligned}
x+0y+\frac{70}{65}z=\frac{275}{65}\\
0x+y+\frac{8}{13}z=\frac{50}{13} \\
0x+0y+(−\frac{225}{65}z)=−\frac{135}{13}
\end{aligned}
\right.
$$

最后消z：
$$
\left\{
\begin{aligned}
x+0y+\frac{70}{65}z=\frac{275}{65}\\
0x+y+\frac{8}{13}z=\frac{50}{13} \\
0x+0y+z=3
\end{aligned}
\right.
$$

$$
\left\{
\begin{aligned}
x+0y+0z=1\\
0x+y+0z=2\\
0x+0y+z=3\\
\end{aligned}
\right.
$$

显然得到答案
$$
x=1,y=2,z=3
$$

## 代码实现

使用了根本不熟悉的c++，所以也没有使用c++太多的独有语法

题目有很多打印和输入要求，但也有些许关联，主要就是函数void LinearEqs()中就是具体代码了

文章主要参考内容:[高斯消元法&高斯-约旦消元法-Mine_King](https://www.cnblogs.com/mk-oi/p/14290455.html)

[高斯-若尔当消元法-百度百科](https://baike.baidu.com/item/%E9%AB%98%E6%96%AF-%E8%8B%A5%E5%B0%94%E5%BD%93%E6%B6%88%E5%85%83%E6%B3%95/19969775)

```
#include<bits/stdc++.h>
#include <iostream>
using namespace std;


int m; //列
int n; //行
double matrix[100][100];
double ans[100][100];
double eps=1e-20; //小量
bool flag = true;
int countt =1;

void init(){
    cout<<"Please enter number of equations(m):";
    scanf("%d", &m);
    cout<<"Please enter number of equations(n):";
    scanf("%d", &n);
    cout<< "Input:m="<< m <<",n="<< n << endl; 
    cout<<"Please enter equations(x1 x2 xn a)"<<endl;
    for(int i = 0;i<n;i++){
        cout<< "Equation"<<" "<<"#"<< i+1 <<": ";
        for(int j = 0;j<=m;j++) {
            scanf("%lf", &matrix[i][j]);
        }
    }
}

void printMatrix(){

    if(countt == 0){
        cout<<"matrix before the transformation:"<<endl<<endl;
        countt++;
    }else{
        cout<<"matrix after the transformation:"<<endl<<endl;
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<=m;j++){
            cout.setf(ios::fixed);
            cout<< "      ";
            cout<<setw(8);
            cout<<setprecision(6);
            cout<<matrix[i][j];
        }
        cout<<endl;
    }

}

void printSolution(){
    if(!flag){
        puts("No Solution");
        return;
    }
    puts("The only solution is:\n");
    for(int i=0;i<n;i++){
        cout<<"x"<<i+1<<"=";
        cout<<setprecision(6);
        cout<<matrix[i][m]/matrix[i][i]<<endl;
    }
    
}


void LinearEqs(){
    for(int i=0;i<n;++i){  
        int max = i;
        for(int j=i+1;j<n;j++ ){
            if(fabs(matrix[j][i])>fabs(matrix[max][i])) {	//fabs取浮点数的绝对值
                max=j;
			}   
        }

        for(int j =0;j<=m;j++){
            swap(matrix[i][j],matrix[max][j]);
        }


        if(fabs(matrix[i][i]) < eps ){ //最大值小于eps无解
            flag = false;
        }

        // for(int j=0;j<n;j++){   //未化为单位矩阵但是结果也正确
    
        //     if(j!=i){  
        //         double temp = matrix[j][i] /matrix[i][i];    
        //         for(int k=i+1;k<=m;k++){
        //         matrix[j][k] -= matrix[i][k]*temp; //减消元
        //         }
        //     } 
        // }

        for(int j=i+1;j<m+1;j++){
            matrix[i][j] /=matrix[i][i];
        }
        matrix[i][i]=1;

        for(int j=0;j<n;j++){
            if(j!=i){ 
                for(int k=i+1;k<=m;k++){
                    matrix[j][k] -= matrix[j][i]*matrix[i][k];
                }
                matrix[j][i]=0;
            }
        }
        


    }
}




int main(){
    init();
    printMatrix();
    LinearEqs();
    printMatrix();
    printSolution();
    return 0;
}
```

