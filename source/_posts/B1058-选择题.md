---
title: B1058-选择题 
date: 2019-11-5 3:34:12 
categories: PAT练习
tags:
- 正则表达式
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/id=57171771(BoCuden).50wbrbiulzc0.jpg
---

## 题目描述 <!--more-->

 批改多选题是比较麻烦的事情，本题就请你写个程序帮助老师批改多选题，并且指出哪道题错的人最多。 

## 输入描述

>输入在第一行给出两个正整数 N（≤ 1000）和 M（≤ 100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 `(选中的选项个数 选项1 ……)`，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。 

## 输出描述:

>按照输入的顺序给出每个学生的得分，每个分数占一行。注意判题时只有选择全部正确才能得到该题的分数。最后一行输出错得最多的题目的错误次数和编号（题目按照输入的顺序从 1 开始编号）。如果有并列，则按编号递增顺序输出。数字间用空格分隔，行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 `Too simple`。 

## 示例

### 输入

> 3 4 
> 3 4 2 a c
> 2 5 1 b
> 5 3 2 b c
> 1 5 4 a b d e
> (2 a c) (2 b d) (2 a c) (3 a b e)
> (2 a c) (1 b) (2 a b) (4 a b d e)
> (2 b d) (1 e) (2 b c) (4 a b c d)

### 输出

> 3
> 6
> 5
> 2 2 3 4

## 解题思路：

- 这个正则表达式是直接拿别人用的 "\\)\\s*\\("

- 对(2 a c)  (2 b d)  (2 a c)  (3 a b e)使用效果为

- 2 a c
  2 b d
  2 a c
  3 a b e

  挺难理解的，使用前需要先删去第一个(和最后一个)，效果就是按照)  (这样一个组合分割

- 不过正则表达式用法千奇百怪也不能指望都懂了。

- 分割后得到的格式是同正确答案格式一样的，可以直接判断如果equals这道题就是对的

- 最后输出一道题最多错了多少人，加上有着同样该错误数量的题目，可以是多个

- [^a-zA-Z]是去匹配目标字符串中非a—z也非A—Z的字符 

- 匹配非字母替换为空串，然后题目要求字母不区分大小写所以全部变成大写或者小写减去ascll码就行

- 使用Integer.toBinaryString()把数变成二进制，

-  得到该字符串去除1之后的长度，也就是零的长度，再把原长度减去零的长度就是1的长度。

---

---



```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 2 2 3 4，第一个2，是错误最多的次数，234是三个不同的题号，搞清这个就明白很多了
 */
public class PAT_B1058 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] temp = br.readLine().split(" ");
        int n = Integer.parseInt(temp[0]);//学生人数
        int m = Integer.parseInt(temp[1]);//多选题个数
        int[] score = new int[m];//每道题的总分
        int[] wrong = new int[m];//每道题做错人数
        String[] right = new String[m];//每道题的正确答案

        for (int i = 0; i <m ; i++) {
            String str = br.readLine();
            score[i] = Integer.parseInt(str.substring(0,1));
            right[i] = str.substring(4);
        }

        int[] studentS = new int[n];
        for (int i = 0; i <n ; i++) {
            String s = br.readLine();
            s = s.substring(s.indexOf('(') + 1, s.lastIndexOf(')'));
            String[] reset = s.split("\\)\\s*\\(");
            for (int j = 0; j <reset.length ; j++) {
                if (reset[j].equals(right[j])){
                    studentS[i] += score[j];
                }else {
                    wrong[j]++;
                }
            }
            System.out.println(studentS[i]);
        }

        int maxIndex = 0;
        for (int i = 0; i <m ; i++) {
            if (wrong[i]>wrong[maxIndex]){
                maxIndex = i;
            }
        }
        if (wrong[maxIndex]==0){
            System.out.println("Too simple");
        }else {
            System.out.print(wrong[maxIndex]);
            for (int i = 0; i <m ; i++) {
                if (wrong[i] == wrong[maxIndex]){
                    System.out.printf(" %d",i+1);
                }
            }

        }
    }
}
```

