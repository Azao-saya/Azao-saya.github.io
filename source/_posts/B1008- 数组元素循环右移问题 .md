---
title: B1008- 数组元素循环右移问题
date: 2019-10-16 1:45:12 
categories: PAT练习
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/1V4VU0}01W0YI37`J7XNTVP.2auoqywiwvfo.jpg
---
## 题目描述 <!--more-->
  一个数组*A*中存有*N*（>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移*M*（≥0）个位置，即将*A*中的数据由（*A*0*A*1⋯*A**N*−1）变换为（*A**N*−*M*⋯*A**N*−1*A*0*A*1⋯*A**N*−*M*−1）（最后*M*个数循环移至最前面的*M*个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？

  ## 输入描述

  >  每个输入包含一个测试用例，第1行输入*N*（1≤*N*≤100）和*M*（≥0）；第2行输入*N*个整数，之间用空格分隔。 

  ## 输出描述:

  >  在一行中输出循环右移*M*位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 

  ## 示例

  ### 输入

  > 6 2
  >
  > 1 2 3 4 5 6

  ### 输出

  > 5 6 1 2 3 4

  ## 解题思路：

  - 移动次数超过数组大小会产生错误，在录入时直接进行取余

------

------

```
import java.io.BufferedInputStream;
import java.util.Scanner;

public class PAT_B1008 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(new BufferedInputStream(System.in));
        int m = sc.nextInt();
        int n = sc.nextInt()%m; //关键：对n进行一次取余
        int[] num = new int[m];
        for (int i = 0; i < m ; i++) {
            if (i+n < num.length){
                num[i+n] = sc.nextInt();
            }else {
                for (int j = 0; j < n ; j++) {
                    num[j] = sc.nextInt();
                }
                break;
            }
        }
        for (int i = 0; i < m ; i++) {
            System.out.print(num[i]);
            if (i == m-1){
                break;
            }
            System.out.print(" ");
        }
    }
}
```

