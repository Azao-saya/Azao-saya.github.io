---
title: B1019-数字黑洞
date: 2019-10-16 15:45:12 
categories: PAT练习
tags:
- compare
- 正则表达式
- 字符串操作
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/QQ图片20200131234133.3wh4kqrq5s20.jpg
---

## 题目描述 <!--more-->

-  给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 `6174`，这个神奇的数字也叫 Kaprekar 常数。

  例如，我们从`6767`开始，将得到

  ```
  7766 - 6677 = 1089
  9810 - 0189 = 9621
  9621 - 1269 = 8352
  8532 - 2358 = 6174
  7641 - 1467 = 6174
  ... ...
  ```

  现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。

## 输入描述

>     输入给出一个 (0,104) 区间内的正整数 *N*。  

## 输出描述:

>   如果 *N* 的 4 位数字全相等，则在一行内输出 `N - N = 0000`；否则将计算的每一步在一行内输出，直到 `6174` 作为差出现，输出格式见样例。注意每个数字按 `4` 位数格式输出。 

## 示例

### 输入

> 6767

### 输出

> 7766 - 6677 = 1089
> 9810 - 0189 = 9621
> 9621 - 1269 = 8352
> 8532 - 2358 = 6174



### 输入

> 2222

### 输出

> 2222 - 2222 = 0000

## 解题思路：

-  录入数据后取出每一个字符串，用Arrays.sort进行倒序排序
-  StringBuilder拼接起来，然后再正序排序拼接
-  取得字符串的int值赋值给数字黑洞用于下一次计算
-  输出数字黑洞两个拼接的字符串和数字黑洞补全零，进入下个循环

-----

-----

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Comparator;


public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        int n1 = Integer.parseInt(String.valueOf(br.readLine()));
        String s = String.format("%04d",n1);
        char[] ch = s.toCharArray();
        int numBlackHole = 0;

        while (numBlackHole != 6174){
            if(numBlackHole !=0){
                ch = String.format("%04d",numBlackHole).toCharArray();
            }
            Integer[] num1 = new Integer[4];
            for(int i=0;i<ch.length;i++) {
                num1[i] = Integer.parseInt(String.valueOf(ch[i]));
            }
            Comparator cmp = new MyComparator();
            Arrays.sort(num1,cmp);
            StringBuilder reNum = new StringBuilder();
            StringBuilder num = new StringBuilder();
            for (int i = 0; i <4 ; i++) {
                reNum.append(num1[i]);
            }
            Arrays.sort(num1);
            for (int i = 0; i <4 ; i++) {
                num.append(num1[i]);
            }
            numBlackHole = Integer.parseInt(String.valueOf(reNum)) - Integer.parseInt(String.valueOf(num));
            System.out.println(reNum+" - "+num+" = "+String.format("%04d",numBlackHole));
            if (numBlackHole==0){
                break;
            }
        }
    }
}

class MyComparator implements Comparator<Integer> {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o2 - o1;
    }
}
```

