---
title: B1074-宇宙无敌加法器
date: 2019-11-9 8:34:12 
categories: PAT练习
tags:
- 字符串操作
- 正则表达式
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/id=55325876(loundraw).78z228rx71o0.jpg
---

## 题目描述 <!--more-->

地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。

在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。

## 输入描述

>输入首先在第一行给出一个 N 位的进制表（0 < N ≤ 20），以回车结束。 随后两行，每行给出一个不超过 N 位的非负的 PAT 数。 

## 输出描述:

>在一行中输出两个 PAT 数之和。 

### 输入

> 30527
> 06203
> 415

### 输出

> 7201

> 

## 解题思路：

- StringBuilder的.insert()是在某个位置插入输入的内容，为0的话就是一直在前面插入，达到逆序。
- 相加时会有三种情况
- 第一串数字已经没有数字只加第二串，第二串数字已经没有数字只加第一串，第一串第二串都还有数字两个数字想加
- 把和按照进制取余，若有余数则进一位，下次的和额外+1。判断是取余后得到数是否小于原来的和，小于则是有余数。
- 这里写的不太严谨，直接拿最初的和来对比了，应该是可能+1后的和来对比。
- 不过代码是ac的，好程序和ac确实是两个概念。听说有人是在摸索出测试用例直接特判输出来达到ac。
- 只能说太强了。
- 最后的正则表达式为删除最前面的所有零，用^0+或者^0*都可以
- 最后的最后如果ans是空串了，即和为零但最开始的零全部会被删除。则自行输出零

---

---



```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class PAT_B1074 {
    public static void main(String[] args) throws IOException { //以为简单的题坑也太多了
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String system = br.readLine();
        String num1 = br.readLine();
        String num2 = br.readLine();
        StringBuilder sb = new StringBuilder();
        int increase = 0;
        for (int i = num1.length()-1, j = system.length()-1,k = num2.length()-1;(i >=0 || k>=0) && j>=0 ;i--,j--,k--) {
            int systemT = Integer.parseInt(String.valueOf(system.charAt(j)));
            if (systemT==0){
                systemT =10;
            }
            int sum = 0;
            if (k <0){
                sum = Integer.parseInt(String.valueOf(num1.charAt(i)));
            }else if(i <0) {
                sum = Integer.parseInt(String.valueOf(num2.charAt(k)));
            }else {
                sum = Integer.parseInt(String.valueOf(num1.charAt(i)))+Integer.parseInt(String.valueOf(num2.charAt(k)));
            }
            int temp2 = (sum+increase) % systemT;
            if (temp2 <sum){
                increase = 1;
            }else {
                increase = 0;
            }
            sb.insert(0,temp2);
        }
        if (increase==1){
            sb.insert(0,1);
        }
        String ans = sb.toString().replaceAll("^0*", "");
        System.out.println(ans.length() < 1 ? 0 : ans);
    }
}
```

