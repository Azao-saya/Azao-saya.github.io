---
title: B1040-有几个PAT
date: 2019-11-2 0:34:12 
categories: PAT练习
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/id=69606244.rzhzf5abaxs.png
---

## 题目描述 <!--more-->

-  字符串 `APPAPT` 中包含了两个单词 `PAT`，其中第一个 `PAT` 是第 2 位(`P`)，第 4 位(`A`)，第 6 位(`T`)；第二个 `PAT` 是第 3 位(`P`)，第 4 位(`A`)，第 6 位(`T`)。

  现给定字符串，问一共可以形成多少个 `PAT`？

## 输入描述

>输入只有一行，包含一个字符串，长度不超过105，只包含 `P`、`A`、`T` 三种字母。 

## 输出描述:

>在一行中输出给定字符串中包含多少个 `PAT`。由于结果可能比较大，只输出对 1000000007 取余数的结果。 

## 示例

### 输入

> APPAPT

### 输出

> 2

## 解题思路：

-  这题代码挺抽象的，参考的别人，大概是用计算机思维做的
-  首先统计所有t的数量
-  因为一开始P的计数为零，在读取到A时候才进行总量的计算
-  所以在遇上第一个P之前countp * countt都只会加0，P之前的T也会全部被减去
-  然后前面的所有P都能和之后遇到的A组合，并和再这A之后T组合，但不能和A前面的T组合。
-  也就是P的cnt会一直上升，而能组合的T会越来越少，在遇上T时减去T的cnt。
-  最后的优化就是在total超过1000000007时第一时间进行取余。
-  如果再最后取余会少许增加运行时间，不过两者都没超时。

---

-----

```
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class PAT_B1040 {
    public static void main(String[] args) throws Exception {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        char[] s = in.readLine().toCharArray();
        in.close();
        int len = s.length, countp = 0, countt = 0;
        long total = 0;
        for (int i = 0; i < len; i++) {//先把所有t存入
            if (s[i] == 'T')
                countt++;
        }
        for (int i = 0; i < len; i++) {
            if (s[i] == 'P')
                countp++;
            if (s[i] == 'T')
                countt--;    //t总量-1，第一个p之前的t不会记数
            if (s[i] == 'A') {
                total = total + countp * countt;
                if (total > 1000000007)
                    total = total % 1000000007;//降低运行时间，total非常大若在输出时取余会增加运行时间
            }
        }
        System.out.println(total);
    }
}
```

