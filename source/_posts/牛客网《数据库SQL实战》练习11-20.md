---
title: 牛客网《数据库SQL实战》练习11-20
date: 2020-5-28 5:34:12 
categories: 云笔记
tags:
- MySql
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/61ec1619gy1g0mbfhhm7pj21c00lqwid_看图王.63pc0rpy2uo0.jpg
---

做了10题之后也能够自己动手了，别人讨论还是会看，不同的解法也是继续记录下来学习。<!--more-->


## 11.获取所有员工当前的manager

**题目描述：**

获取所有员工当前的(dept_manager.to_date='9999-01-01')manager，如果员工是manager的话不显示(也就是如果当前的manager是自己的话结果不显示)。输出结果第一列给出当前员工的emp_no,第二列给出其manager对应的emp_no。
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL, -- '所有的员工编号'
`dept_no` char(4) NOT NULL, -- '部门编号'
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `dept_manager` (
`dept_no` char(4) NOT NULL, -- '部门编号'
`emp_no` int(11) NOT NULL, -- '经理编号'
`from_date` date NOT NULL,
`to_date` date NOT NULL,

PRIMARY KEY (`emp_no`,`dept_no`));

**输入描述:**

无

**输出描述:**

| emp_no | manager_no |
| :----: | :--------: |
| 10001  |   10002    |
| 10003  |   10004    |
| 10009  |   10010    |

**解题代码：**

> 1>
>
> select de.emp_no,dm.emp_no as manager_no
> from dept_emp as de inner join dept_manager as dm
> on de.dept_no = dm.dept_no
> where dm.to_date = '9999-01-01' and de.emp_no != dm.emp_no 

**吐槽：**

>题目挺绕的没太说清楚要什么，首先dept_emp是有多个部门所有员工信息的表，dept_manager是多个部门里所有经理的表，比第一张表的范围小很多。
>
>再是加上on de.dept_no = dm.dept_no，因为题意是要找出普通员工的上级经理，不是同一个部门肯定不算上级，最后加上时间约束和把自己就是经理的员工编号删除。
>
><> 和 != 是同一个意思的运算符不同的写法。

## 12.获取所有部门中当前员工薪水最高的相关信息

**题目描述：**

获取所有部门中当前(dept_emp.to_date = '9999-01-01')员工当前(salaries.to_date='9999-01-01')薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,

PRIMARY KEY (`emp_no`,`from_date`));

**输入描述:**

无

**输出描述:**

| dept_no | emp_no | salary |
| :-----: | :----: | ------ |
|  d001   | 10001  | 88958  |

**解题代码：**

> 1>
>
> SELECT d.dept_no, s.emp_no, MAX(s.salary) AS salary
> FROM salaries AS s INNER JOIN dept_emp As d
> ON d.emp_no = s.emp_no 
> WHERE d.to_date = '9999-01-01' AND s.to_date = '9999-01-01'
> GROUP BY d.dept_no
>
> 2>
>
> select r.dept_no,ss.emp_no,r.maxSalary from (
> select d.dept_no,max(s.salary)as maxSalary from dept_emp d,salaries s
> where d.emp_no=s.emp_no
> and d.to_date='9999-01-01' 
> and s.to_date='9999-01-01'
> group by d.dept_no
> )as r,salaries ss,dept_emp dd
> where r.maxSalary=ss.salary
> and r.dept_no=dd.dept_no
> and dd.emp_no=ss.emp_no
> and ss.to_date='9999-01-01'
> and dd.to_date='9999-01-01'
> order by r.dept_no asc
>
> 3>
>
> select r.dept_no,r.emp_no,max(r.salary) from (
> select d.dept_no,d.emp_no,s.salary from dept_emp d,salaries s
> where d.emp_no=s.emp_no
> and d.to_date='9999-01-01' 
> and s.to_date='9999-01-01'
> order by s.salary desc
> )as r
> group by r.dept_no
> order by r.dept_no asc

**吐槽：**

>自己尝试过用limit和order来做，因为mysql的**only_full_group_by** 的默认设置停止了。按照网上的方法尝试修改了一下没成功，好像是因为版本太高了。
>
>**`only_full_group_by`：使用这个就是使用和oracle一样的group 规则, select的列都要在group中,或者本身是聚合列(SUM,AVG,MAX,MIN) 才行**
>
>第一种解题答案也会出现这个问题，导致本地没办法得到结果。不过牛客网的oj是能正常通过的。
>
>第二种能得到多条最高薪水的信息，括号内得到的结果命名为r，但后面两个逗号一度弄的我很懵逼，先前的理解是一定要用`INNER JOIN`,`LEFT JOIN`,`RIGHT JOIN`,`FULL JOIN`来连接多个表，菜鸟教程里也没有说明，换了几次搜索关键词才找到解释，逗号可以当做等价于`inner join`。另外full join好像是别的数据库的语法，不是mysql的。
>
>第三种解法为取出单一一条最高薪水，能通过oj但似乎不严谨，若真有多条最高薪水会出现对不上emp_no的编号。同样的因为only_full_group_by这条没法在本地进行测试。

## 13.从titles表获取按照title进行分组

**题目描述：**

从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。
CREATE TABLE IF NOT EXISTS "titles" (
`emp_no` int(11) NOT NULL,
`title` varchar(50) NOT NULL,
`from_date` date NOT NULL,

`to_date` date DEFAULT NULL);

**输入描述:**

无

**输出描述:**

|       titlet       |  t   |
| :----------------: | :--: |
| Assistant Engineer |  2   |
|      Engineer      |  4   |
|        省略        | 省略 |
|       Staff        |  3   |

**解题代码：**

> 1>
>
> select title,count(title) as t
> from titles 
> group by title having t >= 2
>
> 2>
>
> SELECT title, COUNT(\*) AS t FROM titles
> GROUP BY title
> HAVING COUNT(\*) > 1;

**吐槽：**

>原题题目描述中表名titles用了双引号，之前复制没有添加转义字符``都变成了代码的格式了。
>
>count()函数是用来统计表中记录的一个函数，返回匹配条件的行数。

## 14.从titles表获取按照title进行分组，注意对于重复的emp_no进行忽略

**题目描述：**

从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。
注意对于重复的emp_no进行忽略(即emp_no重复的title不计算，title对应的数目t不增加)。
CREATE TABLE IF NOT EXISTS `titles` (
`emp_no` int(11) NOT NULL,
`title` varchar(50) NOT NULL,
`from_date` date NOT NULL,

`to_date` date DEFAULT NULL);

**输入描述:**

无

**输出描述:**

|       titlet       |  t   |
| :----------------: | :--: |
| Assistant Engineer |  2   |
|      Engineer      |  3   |
|        省略        | 省略 |
|       Staff        |  3   |

**解题代码：**

> select title,count(distinct emp_no) as t
> from titles 
> group by title having t >=2

**吐槽：**

>区别于上题加一个distinct即可

## 15.查找employees表

**题目描述：**

查找employees表所有emp_no为奇数，且last_name不为Mary(注意大小写)的员工信息，并按照hire_date逆序排列(题目不能使用mod函数)
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,

PRIMARY KEY (`emp_no`));

**输入描述:**

无

**输出描述:**

| emp_no | birth_datet | first_name | last_name | gender | hire_date  |
| :----: | :---------: | ---------- | --------- | ------ | ---------- |
| 10011  | 1953-11-07  | Mary       | Sluis     | F      | 1990-01-22 |
| 10005  | 1955-01-21  | Kyoichi    | Maliniak  | M      | 1989-09-12 |
| 10007  | 1957-05-23  | Tzvetan    | Zielinski | F      | 1989-02-10 |
| 10003  | 1959-12-03  | Parto      | Bamford   | M      | 1986-08-28 |
| 10001  | 1953-09-02  | Georgi     | Facello   | M      | 1986-06-26 |
| 10009  | 1952-04-19  | Sumant     | Peac      | F      | 1985-02-18 |

**解题代码：**

> select * from employees
> where emp_no % 2 = 1
> and last_name != 'mary'
> order by hire_date desc

**吐槽：**

>试了一下之前用java做题的方法取余得到奇数，行得通。
>
>看了一下别的讨论oracle好像是用mod（被除数，除数）来取余，并且不等于是只能用 <> 来表示，但上述解法无法通过oj，就不放在解题代码里了。

## 16.统计出当前各个title类型对应的员工当前薪水对应的平均工资

**题目描述：**

统计出当前(titles.to_date='9999-01-01')各个title类型对应的员工当前(salaries.to_date='9999-01-01')薪水对应的平均工资。结果给出title以及平均工资avg。
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));
CREATE TABLE IF NOT EXISTS "titles" (
`emp_no` int(11) NOT NULL,
`title` varchar(50) NOT NULL,
`from_date` date NOT NULL,

`to_date` date DEFAULT NULL);

**输入描述:**

无

**输出描述:**

|      title      |   avg    |
| :-------------: | :------: |
| Senior Engineer | 62409.25 |
|  Senior Staff   | 88070.0  |

**解题代码：**

> select t.title,avg(s.salary) 
> from salaries as s inner join titles as t
> where s.emp_no = t.emp_no 
> and t.to_date='9999-01-01' 
> and s.to_date='9999-01-01'
> group by title

**吐槽：**

>AVG() 函数返回数值列的平均值。

## 17.获取当前薪水第二多的员工的emp_no以及其对应的薪水salary

**题目描述：**

获取当前（to_date='9999-01-01'）薪水第二多的员工的emp_no以及其对应的薪水salary
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

**输入描述:**

无

**输出描述:**

| emp_no | salary |
| :----: | :----: |
| 10009  | 94409  |

**解题代码：**

> 1>
>
> select emp_no,salary 
> from salaries 
> where to_date = '9999-01-01'
> and salary = (select distinct salary from salaries order by salary desc limit 1 offset 1)
>
> 2>
>
> select emp_no, salary
> from salaries
> where salary = (
>     select salary from salaries 
>     group by salary
>     order by salary desc limit 1,1
> ) 
> and to_date = '9999-01-01'

**吐槽：**

>limit 1 offset 1 写成 limit 1,1 也是一样的效果。前者第一个数字意为要提取多少组数据，第二个数字为要从第几位开始，比如2意为从第三位开始。
>
>第二种解法用group by实现了去重

## 18.获取当前薪水第二多的员工的emp_no以及其对应的薪水salary

**题目描述：**

获取当前（to_date='9999-01-01'）薪水第二多的员工的emp_no以及其对应的薪水salary
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

**输入描述:**

无

**输出描述:**

| emp_no | salary | last_name | first_name |
| :----: | :----: | --------- | ---------- |
| 10009  | 94409  | Peac      | Sumant     |

**解题代码：**

> 1>
>
> select e.emp_no,s.salary,e.last_name,e.first_name
> from employees as e inner join salaries as s
> on e.emp_no = s.emp_no
> where s.to_date='9999-01-01' 
> order by salary desc limit 1 offset 1
>
> 2>
>
> SELECT e.emp_no, MAX(s.salary) AS salary, e.last_name, e.first_name 
> FROM employees AS e INNER JOIN salaries AS s 
> ON e.emp_no = s.emp_no
> WHERE s.to_date = '9999-01-01'
> AND s.salary NOT IN (SELECT MAX(salary) FROM salaries WHERE to_date = '9999-01-01')
>
> 3>
>
> select e.emp_no,s.salary,e.last_name,e.first_name
> from
> employees e
> join 
> salaries s on e.emp_no=s.emp_no 
> and  s.to_date='9999-01-01'
> and s.salary = (select max(salary)
>                 from salaries
>                 where salary<(select max(salary) 
>                               from salaries 
>                               where to_date='9999-01-01'
>                              )
>                         and to_date='9999-01-01'
>                 )
>
> 4>
>
> select e.emp_no,s.salary,e.last_name,e.first_name
> from
> employees e
> join 
> salaries s on e.emp_no=s.emp_no 
> and  s.to_date='9999-01-01'
> and s.salary = 
> (
>      select s1.salary
>      from 
>      salaries s1
>      join
>      salaries s2 on s1.salary<=s2.salary 
>      and s1.to_date='9999-01-01' and s2.to_date='9999-01-01'
>      group by s1.salary
>      having count(distinct s2.salary)=2
>  )

**吐槽：**

>第一种自己做的，不过题目也提了一嘴最好不使用order by,就找了别的解法过来。
>
>第三种用max()函数找到比第一个最大值小的最大值，相当于把第一次的最大值给排除了。还是比较好理解的。
>
>第四种用jion连接了同一个表
>
>group by s1.salary
>     having count(distinct s2.salary)=2 比较难理解
>
>查了一下是按照s1分组且满足条件的s2的条数等于2的展示，我运行到group by 为止的语句发现并没有做逆序排序
>
>having count(distinct s2.salary)=2是怎么拿到第二大的值表示疑惑，试了等于1，2，3，4之后发现得到的就是从大到小的值，改成大于等于1却又得到了顺序的结果。那为什么等于1又是最大值呢。
>
>好像关键在on s1.salary<=s2.salary 这句上
>
>目前就留个疑惑吧，以后遇上了在试着得出结论。钻牛角尖效率太低了，也不是没有别的解法。

## 19.查找所有员工的last_name和first_name以及对应的dept_name

**题目描述：**

查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工
CREATE TABLE `departments` (
`dept_no` char(4) NOT NULL,
`dept_name` varchar(40) NOT NULL,
PRIMARY KEY (`dept_no`));
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,

PRIMARY KEY (`emp_no`));

**输入描述:**

无

**输出描述:**

| last_name | first_namesalary | dept_namelast_name |
| :-------: | :--------------: | ------------------ |
|  Facello  |   Georgi94409    | MarketingPeac      |
|   省略    |       省略       | 省略               |
|   Sluis   |       Mary       | NULL               |

**解题代码：**

> select e.last_name,e.first_name,d.dept_name 
>
> from employees as e 
>
> left join dept_emp as de on e.emp_no=de.emp_no 
>
> left join departments as d on de.dept_no=d.dept_no;
>
> 

**吐槽：**

>方法就是用left join连接两次
>
>因为需要保留更多的信息，所以第一个左表是信息最多employees，然后是依次减少。

## 20.查找员工编号emp_no为10001其自入职以来的薪水salary涨幅(总共涨了多少)growth

**题目描述：**

查找员工编号emp_no为10001其自入职以来的薪水salary涨幅(总共涨了多少)growth(可能有多次涨薪，没有降薪)
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));

**输入描述:**

无

**输出描述:**

| growth |
| :----: |
| 28841  |

> 1>
>
> select (max(salary)-min(salary)) as growth
> from salaries  where emp_no='10001' 
>
> 2>
>
> SELECT ( 
> (SELECT salary FROM salaries WHERE emp_no = 10001 ORDER BY to_date DESC LIMIT 1) -
> (SELECT salary FROM salaries WHERE emp_no = 10001 ORDER BY to_date ASC LIMIT 1)
> ) AS growth

**吐槽：**

>一开始以为是要涨幅次数，再看了一眼发现是要总共涨了多少，那就直接用max和min了
>
>看到第二种方法查了一下可不可以用limit获取最后一个数据，发现只能用逆序来，那就重新写一遍了