---
title: B1095-解码PAT准考证（分类存在问题，标签云是正常的）
date: 2019-12-3 6:34:12 
categories: PAT练习
tags:
- 未AC题目
- 正则表达式
- HashMap
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/5.id=75992949.67ub5prkgnc0.png
---

## 题目描述 <!--more-->

PAT 准考证号由 4 部分组成：

- 第 1 位是级别，即 `T` 代表顶级；`A` 代表甲级；`B` 代表乙级；
- 第 2~4 位是考场编号，范围从 101 到 999；
- 第 5~10 位是考试日期，格式为年、月、日顺次各占 2 位；
- 最后 11~13 位是考生编号，范围从 000 到 999。

现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。

## 输入描述

>  输入首先在一行中给出两个正整数 N（≤10
>  4
>   ）和 M（≤100），分别为考生人数和统计要求的个数。
>
>  接下来 N 行，每行给出一个考生的准考证号和其分数（在区间 [0,100] 内的整数），其间以空格分隔。
>
>  考生信息之后，再给出 M 行，每行给出一个统计要求，格式为：类型 指令，其中
>
>  类型 为 1 表示要求按分数非升序输出某个指定级别的考生的成绩，对应的 指令 则给出代表指定级别的字母；
>  类型 为 2 表示要求将某指定考场的考生人数和总分统计输出，对应的 指令 则给出指定考场的编号；
>  类型 为 3 表示要求将某指定日期的考生人数分考场统计输出，对应的 指令 则给出指定日期，格式与准考证上日期相同。

## 输出描述

>   对每项统计要求，首先在一行中输出 Case #: 要求，其中 # 是该项要求的编号，从 1 开始；要求 即复制输入给出的要求。随后输出相应的统计结果：
>
>   类型 为 1 的指令，输出格式与输入的考生信息格式相同，即 准考证号 成绩。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）；
>   类型 为 2 的指令，按 人数 总分 的格式输出；
>   类型 为 3 的指令，输出按人数非递增顺序，格式为 考场编号 总人数。若人数并列则按考场编号递增顺序输出。
>   如果查询结果为空，则输出 NA。

## 示例

### 输入

> 8 4
> B123180908127 99
> B102180908003 86
> A112180318002 98
> T107150310127 62
> A107180908108 100
> T123180908010 78
> B112160918035 88
> A107180908021 98
> 1 A
> 2 107
> 3 180908
> 2 999

### 输出

> Case 1: 1 A
> A107180908108 100
> A107180908021 98
> A112180318002 98
> Case 2: 2 107
> 3 260
> Case 3: 3 180908
> 107 2
> 123 2
> 102 1
> Case 4: 2 999
> NA

## 解题思路：

- 排序问题，按照3种不同的指令输出三种结果。
- 类型1，分别有T、A、B三种输入。从map里取出准考证，在单独取出第一位字母判断是否与输入的字母相同。若相同则保存
- 类型2，输入的为第2~4位的考场编号。取出准考证后用subString截取(1,4)位。若与输入相同则保存
- 类型3也是一样。
- 全部存入后按照题意排序。分数和人数是降序排序，若数字相同。则按其准考证号的字典序递增输出，compareTo能进行这个判断。

---

---



```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

/**
 * 提交时间	             状态	  分数	 题目	  编译器	     耗时	用户
 * 2019/11/24 02:17:26  部分正确   16    1095    Java (openjdk)	 86 ms	決别
 * Case 2,3,4:TLE
 * 写出来就感觉要超时了，优化的话网上没找到别人的java代码，大概是止步于此了。
 * 马上就是12月份的正式考试了，我很感谢这107道习题让我正式的入门了java。
 * 我不知道是不是在就业的路上走偏了，但是这条路我没有退路也决不会放弃。
 */
public class PAT_B1095 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] temp = br.readLine().split(" ");
        int n = Integer.parseInt(temp[0]);
        int m = Integer.parseInt(temp[1]);
        Map<String,Integer> map = new HashMap<>();

        for (int i = 0; i <n ; i++) {
            String[] s = br.readLine().split(" ");
            map.put(s[0],Integer.parseInt(s[1]));
        }

        for (int i = 0; i <m ; i++) {
            ArrayList<Node3> list = new ArrayList<>();
            String[] s2 = br.readLine().split(" ");
            int sum = 0,count = 0;
            int number = Integer.parseInt(s2[0]);
            if (number ==1){
                char c = s2[1].toCharArray()[0];
                for(Map.Entry<String, Integer> entry : map.entrySet()){
                    String mapKey = entry.getKey();
                    if (mapKey.charAt(0) == c){
                        list.add(new Node3(mapKey,entry.getValue()));
                    }
                }
                Collections.sort(list,new Node3CMP());
            }else if(number == 2){
                for(Map.Entry<String, Integer> entry : map.entrySet()){
                    String mapKey = entry.getKey().substring(1,4);
                    if (mapKey.equals(s2[1])){
                        count++;
                        sum += entry.getValue();
                    }
                }
            }else {
                Map<String,Integer> map2 = new HashMap<>();
                for(Map.Entry<String, Integer> entry : map.entrySet()){
                    String mapKeyT = entry.getKey();
                    String mapKey1 = mapKeyT.substring(4,10);
                    String mapKey2 = mapKeyT.substring(1,4);
                    if (mapKey1.equals(s2[1])){
                        if (map2.containsKey(mapKey2)){
                            map2.put(mapKey2,map2.get(mapKey2)+1);
                            continue;
                        }
                        map2.put(mapKey2,1);
                    }
                }
                for(Map.Entry<String, Integer> entry : map2.entrySet()){
                    list.add(new Node3(entry.getKey(),entry.getValue()));
                }
                Collections.sort(list,new Node3CMP());
            }

            System.out.printf("%s %d: %s %s\n","Case",i+1,s2[0],s2[1]);
            if (list.size() == 0 && count==0){
                System.out.println("NA");
            }else if (count !=0){
                System.out.println(count+" "+sum);
            }else {
                for (Node3 n3 : list) {
                    System.out.println(n3.id+" "+n3.value);
                }
            }
        }
    }
}

class Node3{
    String id;
    int value;
    public Node3(String id,int value){
        this.id = id;
        this.value = value;
    }
}

class Node3CMP implements Comparator<Node3> {
    public int compare(Node3 o1,Node3 o2){
        int x = o2.value - o1.value;
        if (x == 0){
            return o1.id.compareTo(o2.id);
        }else {
            return x;
        }
    }
}
```

