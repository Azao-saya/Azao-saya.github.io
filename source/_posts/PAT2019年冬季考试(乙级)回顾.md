---
title: PAT2019年冬季考试(乙级)回顾
date: 2019-12-8 14:34:12 
categories: PAT练习
tags:
- 参加的考试
top: 8
cover: https://s2.ax1x.com/2019/12/14/Q2bR8H.png
---

  很有幸和这么多大佬一起陪考了这次2019冬季考试，也很幸运的能有机会见到pat的出题人陈越姥姥，看着陈越姥姥给满分的同学拍照一起面带笑容讨论考研和计算机的未来前景，内心着实是十分欣羡和向往这种生活，却又与67的我显得格格不入。 <!--more-->

  因为程序已经没有提交的入口了，重做也无法知道自己有没有做对。

  所以这篇博客并不是题解而是给自己与pat短暂的相处画上句号。

# 7-1 2019数列

把 2019 各个数位上的数字 2、0、1、9 作为一个数列的前 4 项，用它们去构造一个无穷数列，其中第 *n*（>4）项是它前 4 项之和的个位数字。例如第 5 项为 2， 因为 2+0+1+9=12，个位数是 2。

本题就请你编写程序，列出这个序列的前 *n* 项。

## 输入描述

>   输入给出正整数 *n*（≤1000）。 

## 输出描述:

>  在一行中输出数列的前 *n* 项，数字间不要有空格。 

### 输入

> 10

### 输出

> 2019224758

 **题外话：**这个数列中永远不会出现 `2018`，你能证明吗？ 

- 刚上手这道题的时候自己挺紧张的，考试使用的ide Eclipse Oxygen 和我自己使用的版本有所差别。
- 在使用惯用的热键写代码时，一度导致屏幕里显示的内容翻转了....
- 老师当时离开了教室一会，呼救没人搭理....只能自己小心翼翼的调整了回来。
- 加上有规定不能打开游览器否则按作弊处理，而谷歌游览器就在任务栏上.....
- 之后的考试时间就格外的小心除了ctrl+c ctrl+v和alt+/没有再使用别的热键了。
- 也为之后的超时埋下了伏笔
- 言归正传这题没啥难度，注意n<4的能正常输出内容即可。
- 同时PAT的OJ和别的OJ不同，会严格检查多余的空格，输出时最好带上trim()。

---

---

```
import java.io.*;


public class Main {

	public static void main(String[] args) throws IOException{
		// TODO Auto-generated method stub
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		StringBuilder sb = new StringBuilder();
		int[] list = new int[1001];
		list[0]=2;
		list[1]=0;
		list[2]=1;
		list[3]=9;
		if(n<4) {
			for(int i =0;i<n;i++) {
				sb.append(list[i]);
			}
			System.out.println(sb.toString().trim());
			System.exit(0);
		}
		sb.append(2019);
		for(int i =4;i<n;i++) {
			int sum =0;
			for(int j =i-4;j<i;j++) {
				sum +=list[j];
			}
			sum = sum%10;
			list[i] = sum;
			sb.append(sum);
		}
		System.out.println(sb.toString().trim());
	}

}
```

# 7-2 老鼠爱大米

翁恺老师曾经设计过一款 Java 挑战游戏，叫“老鼠爱大米”（或许因为他的外号叫“胖胖鼠”）。每个玩家用 Java 代码控制一只鼠，目标是抢吃尽可能多的大米让自己变成胖胖鼠，最胖的那只就是冠军。

因为游戏时间不能太长，我们把玩家分成 *N* 组，每组 *M* 只老鼠同场竞技，然后从 *N* 个分组冠军中直接选出最胖的冠军胖胖鼠。现在就请你写个程序来得到冠军的体重。

## 输入描述

>  输入在第一行中给出 2 个正整数：N（≤100）为组数，M（≤10）为每组玩家个数。随后 N 行，每行给出一组玩家控制的 M 只老鼠最后的体重，均为不超过 10
>  4
>    的非负整数。数字间以空格分隔。

## 输出描述:

> 首先在第一行顺次输出各组冠军的体重，数字间以 1 个空格分隔，行首尾不得有多余空格。随后在第二行输出冠军胖胖鼠的体重。 

### 输入

> 3 5
> 62 53 88 72 81
> 12 31 9 0 2
> 91 42 39 6 48

### 输出

> 88 31 91
> 91

- 这题设置两个最大值，最近考试姥姥给的运行时间很充裕，程序一遍写下来就能过。
- 不过java的话太多输入还是会超时，最后两题都是有超时的测试点。而我最后一题甚至只才写了一个开头就已经超时了。

---

---

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

	public static void main(String[] args) throws IOException{
		// TODO Auto-generated method stub
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] temp = br.readLine().split(" ");
		int n = Integer.parseInt(temp[0]);
		int m = Integer.parseInt(temp[1]);
		int[] Fat = new int[n];
		int maxFat =0;
		for(int i =0; i<n;i++) {
			int smallFat =0;
			String[] str = br.readLine().split(" ");
			for(int j =0; j<m;j++) {
				int num = Integer.parseInt(str[j]);
				if(num > smallFat) {
					smallFat = num;
				}
			}
			if(maxFat<smallFat) {
				maxFat = smallFat;
			}
			if(i==0) {
				System.out.print(smallFat);
			}else {
				System.out.print(" "+smallFat);
			}
			
		}
		System.out.println();
		System.out.println(maxFat);
		
	}

}
```

# 7-3 String复读机

给定一个长度不超过 10^4的、仅由英文字母构成的字符串。请将字符重新调整顺序，按 StringString.... （注意区分大小写）这样的顺序输出，并忽略其它字符。当然，六种字符的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按 String 的顺序打印，直到所有字符都被输出。例如 gnirtSSs 要调整成 StringS 输出，其中 s 是多余字符被忽略。

## 输入描述

>  输入在一行中给出一个长度不超过 10^4的、仅由英文字母构成的非空字符串。

## 输出描述:

> 在一行中按题目要求输出排序后的字符串。题目保证输出非空。

### 输入

> sTRidlinSayBingStrropriiSHSiRiagIgtSSr

### 输出

> StringStringSrigSriSiSii

- 设置两个数组，一组直接存放“String”的每个字母，一组记录每个字母的出现次数。
- 题目感觉稍稍放水了，大小写是区分的不用再加判断了。

---

---

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

	public static void main(String[] args) throws IOException{
		// TODO Auto-generated method stub
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String input = br.readLine();
		int[] string = new int[10];
		String[] s = {"S","t","r","i","n","g"};
		for(int i = 0;i<input.length();i++) {
			char c = input.charAt(i);
			if(c =='S') {
				string[0]++;
			}else if(c =='t') {
				string[1]++;
			}else if(c =='r') {
				string[2]++;
			}else if(c == 'i') {
				string[3]++;
			}else if(c == 'n') {
				string[4]++;
			}else if(c == 'g') {
				string[5]++;
			}
		}
		StringBuilder sb = new StringBuilder();
		for(int i =0;i<input.length();i++) {
			for(int j =0;j<6;j++) {
				if(string[j]!=0) {
					string[j]--;
					sb.append(s[j]);
				}
			}
		}
		System.out.println(sb.toString().trim());
	}

}
```

# 7-4 擅长C

当你被面试官要求用 C 写一个“Hello World”时，有本事像下图显示的那样写一个出来吗？

 ![HWC.jpg](https://images.ptausercontent.com/ba3b8678-061d-4fc6-a87e-ce08e1434410.jpg) 

## 输入描述

>  输入首先给出 26 个英文大写字母 A-Z，每个字母用一个 7×5 的、由 `C` 和 `.` 组成的矩阵构成。最后在一行中给出一个句子，以回车结束。句子是由若干个单词（每个包含不超过 10 个连续的大写英文字母）组成的，单词间以任何非大写英文字母分隔。
>
>  题目保证至少给出一个单词。

## 输出描述:

> 对每个单词，将其每个字母用矩阵形式在一行中输出，字母间有一列空格分隔。单词的首尾不得有多余空格。
>
> 相邻的两个单词间必须有一空行分隔。输出的首尾不得有多余空行。

### 输入

> ..C..
> .C.C.
> C...C
> CCCCC
> C...C
> C...C
> C...C
> CCCC.
> C...C
> C...C
> CCCC.
> C...C
> C...C
> CCCC.
> .CCC.
> C...C
> C....
> C....
> C....
> C...C
> .CCC.
> CCCC.
> C...C
> C...C
> C...C
> C...C
> C...C
> CCCC.
> CCCCC
> C....
> C....
> CCCC.
> C....
> C....
> CCCCC
> CCCCC
> C....
> C....
> CCCC.
> C....
> C....
> C....
> CCCC.
> C...C
> C....
> C.CCC
> C...C
> C...C
> CCCC.
> C...C
> C...C
> C...C
> CCCCC
> C...C
> C...C
> C...C
> CCCCC
> ..C..
> ..C..
> ..C..
> ..C..
> ..C..
> CCCCC
> CCCCC
> ....C
> ....C
> ....C
> ....C
> C...C
> .CCC.
> C...C
> C..C.
> C.C..
> CC...
> C.C..
> C..C.
> C...C
> C....
> C....
> C....
> C....
> C....
> C....
> CCCCC
> C...C
> C...C
> CC.CC
> C.C.C
> C...C
> C...C
> C...C
> C...C
> C...C
> CC..C
> C.C.C
> C..CC
> C...C
> C...C
> .CCC.
> C...C
> C...C
> C...C
> C...C
> C...C
> .CCC.
> CCCC.
> C...C
> C...C
> CCCC.
> C....
> C....
> C....
> .CCC.
> C...C
> C...C
> C...C
> C.C.C
> C..CC
> .CCC.
> CCCC.
> C...C
> CCCC.
> CC...
> C.C..
> C..C.
> C...C
> .CCC.
> C...C
> C....
> .CCC.
> ....C
> C...C
> .CCC.
> CCCCC
> ..C..
> ..C..
> ..C..
> ..C..
> ..C..
> ..C..
> C...C
> C...C
> C...C
> C...C
> C...C
> C...C
> .CCC.
> C...C
> C...C
> C...C
> C...C
> C...C
> .C.C.
> ..C..
> C...C
> C...C
> C...C
> C.C.C
> CC.CC
> C...C
> C...C
> C...C
> C...C
> .C.C.
> ..C..
> .C.C.
> C...C
> C...C
> C...C
> C...C
> .C.C.
> ..C..
> ..C..
> ..C..
> ..C..
> CCCCC
> ....C
> ...C.
> ..C..
> .C...
> C....
> CCCCC
> HELLO~WORLD!

### 输出

> ```out
> C...C CCCCC C.... C.... .CCC.
> C...C C.... C.... C.... C...C
> C...C C.... C.... C.... C...C
> CCCCC CCCC. C.... C.... C...C
> C...C C.... C.... C.... C...C
> C...C C.... C.... C.... C...C
> C...C CCCCC CCCCC CCCCC .CCC.
> 
> C...C .CCC. CCCC. C.... CCCC.
> C...C C...C C...C C.... C...C
> C...C C...C CCCC. C.... C...C
> C.C.C C...C CC... C.... C...C
> CC.CC C...C C.C.. C.... C...C
> C...C C...C C..C. C.... C...C
> C...C .CCC. C...C CCCCC CCCC.
> ```

- 如果说上一题让我有了姥姥放水了能轻松拿个高分的错觉，这题则是直接击碎了我的幻想。
- 这么长的输入样例，可以说是生平仅见。我花了非常多的时间理解题目和写代码。
- 最后只通过一个测试点，剩下的测试点是两个格式错误一个运行超时和答案错误。
- 无法想象在大致做出题目之后，仍有这么多各式各样的错误。
- 我果断放弃了这题的完全得分，只想找出格式错误的原因增加判断来达到匹配。
- 结果仍是事与愿违，这题没有再多得一分。
- 在考试最后的25分钟里我望向了第五道题，却是见到了我之前在博客里白纸黑字写着放弃的题型，链表。
- 虽是对解法还有大致思路，不过剩余的时间不足以我拼凑起代码，本次考试只能止步于此。
- 人生怕什么就容易来什么，逃避还是得不到真正的解决。

---

---

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;

public class Main {

	public static void main(String[] args) throws IOException{
		// TODO Auto-generated method stub
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] abc = new String[26];
		Arrays.fill(abc, "");
		for(int i = 0;i <26;i++) {
			for(int j = 0;j <7;j++) {
				String temp = br.readLine();
				abc[i] +=temp;
				
			}
		}
		String end = br.readLine();
		ArrayList<String> list = new ArrayList<>();
		StringBuilder sb = new StringBuilder();
		for(int i = 0;i <end.length();i++) {
			char c = end.charAt(i);
			if(c>='A'&& c<='Z') {
					sb.append(c);
			}else {
				list.add(sb.toString());
				sb.delete(0, sb.length());
				continue;
			}
		}
		
		for(int i = 0;i <list.size();i++) {
			String temp = list.get(i);
//			System.out.println(temp);
			for(int k=0;k<7;k++) {
				boolean isFirst = true;
				for(int j = 0;j <temp.length();j++) {
					char ch = temp.charAt(j);
					if(isFirst) {
						System.out.print(abc[ch-65].substring(k*5,k*5+5));
						isFirst = false;
					}else {
						System.out.print(" "+abc[ch-65].substring(k*5,k*5+5));
					}
					
				}
				System.out.print("\n");
			}
			if(i!=list.size()-1) {
				System.out.println();
			}
		}
	}

}
```

# 7-5 区块反转

 给定一个单链表 *L*，我们将每 *K* 个结点看成一个**区块**（链表最后若不足 *K* 个结点，也看成一个区块），请编写程序将 *L* 中所有区块的链接反转。例如：给定 *L* 为 1→2→3→4→5→6→7→8，*K* 为 3，则输出应该为 7→8→4→5→6→1→2→3。 

## 输入描述

>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 *N* (≤105)、以及正整数 *K* (≤*N*)，即区块的大小。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。
>
>接下来有 *N* 行，每行格式为：
>
>  ```
>  Address Data Next
>  ```
>
>其中 `Address` 是结点地址，`Data` 是该结点保存的整数数据，`Next` 是下一结点的地址。

## 输出描述:

>  对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。 

### 输入

> 00100 8 3
> 71120 7 88666
> 00000 4 99999
> 00100 1 12309
> 68237 6 71120
> 33218 3 00000
> 99999 5 68237
> 88666 8 -1
> 12309 2 33218

### 输出

> 71120 7 88666
> 88666 8 00000
> 00000 4 99999
> 99999 5 68237
> 68237 6 00100
> 00100 1 12309
> 12309 2 33218
> 33218 3 -1

---

---

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

	public static void main(String[] args) throws IOException{
		// TODO Auto-generated method stub
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[]temp = br.readLine().split(" ");
		String addr = temp[0];
		int n = Integer.parseInt(temp[1]);
		String nex = temp[2];
		Map<String,Node> map = new HashMap<>();
		for(int i =0;i< n;i++) {
			String[]temp2 = br.readLine().split(" ");
			int d = Integer.parseInt(temp2[1]);
			map.put(temp2[0],new Node(temp2[0],d,temp2[2]));
		}
		for(int i =0;i< n;i++) {
			
		}
		System.out.print(-1);
	}
	

}
class Node{
	String add;
	int data;
	String next;
	public Node(String a,int d,String n) {
		this.add = a;
		this.data = d;
		this.next = n;
	}
}	
```