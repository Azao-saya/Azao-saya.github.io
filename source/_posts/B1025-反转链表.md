---
title: B1025-反转链表
date: 2019-10-16 21:45:12 
categories: PAT练习
tags:
- 未AC题目
- 链表
- 正则表达式
- 字符串操作
- reverse
cover: https://cdn.jsdelivr.net/gh/Azao-saya/image-blog@master/20210102/8BH2QH81$`IGRPPDC~E8GVG.4vdx6hbce100.png
---

## 题目描述 <!--more-->

-  给定一个常数 *K* 以及一个单链表 *L*，请编写程序将 *L* 中每 *K* 个结点反转。例如：给定 *L* 为 1→2→3→4→5→6，*K* 为 3，则输出应该为 3→2→1→6→5→4；如果 *K*为 4，则输出应该为 4→3→2→1→5→6，即最后不到 *K* 个元素不反转。 

## 输入描述

>   每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 *N* (≤105)、以及正整数 *K* (≤*N*)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。
>
>   接下来有 *N* 行，每行格式为：
>
>   ```
>   Address Data Next
>   ```
>
>   其中 `Address` 是结点地址，`Data` 是该结点保存的整数数据，`Next` 是下一结点的地址。

## 输出描述:

>   对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。 

## 示例

### 输入

> 00100 6 4
> 00000 4 99999
> 00100 1 12309
> 68237 6 -1
> 33218 3 00000
> 99999 5 68237
> 12309 2 33218

### 输出

> 00000 4 33218
> 33218 3 12309
> 12309 2 00100
> 00100 1 99999
> 99999 5 68237
> 68237 6 -1

## 解题思路：

- 无法解决的超时

- 此处贴的别人的代码，自己写的测试了很多次都没有问题。提交就全错。花了很多时间无果看着堆积如山需要速成的内容遂决定放弃。

-----

-----

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;


public class PAT_B1025_2 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] s = br.readLine().split(" ");
        int firstAddress = Integer.parseInt(s[0]);
        int n = Integer.parseInt(s[1]);
        int k = Integer.parseInt(s[2]);
        Node[] list = new Node[100000];
        for (int i = 0; i < n; i++) {
            String[] str = br.readLine().split(" ");
            Node temp = new Node(Integer.parseInt(str[0]), Integer.parseInt(str[1]), Integer.parseInt(str[2]));
            list[temp.address] = temp;
        }
        br.close();
        List<Node> array = new ArrayList<>();
        link(list, firstAddress, array);
        reverse(array, k);
        for (int i = 0; i < array.size() - 1; i++) {
            System.out.printf("%05d %d %05d\n", array.get(i).address,
                    array.get(i).data, array.get(i + 1).address);
        }
        int end = array.size() - 1;
        System.out.printf("%05d %d -1", array.get(end).address,
                array.get(end).data);
    }
    public static void reverse(List<Node> array, int k) {
        for (int i = 0; i + k <= array.size(); i += k) {
            for (int m = i + k - 1, n = i; m >= n; m--, n++) {
                Node temp = array.get(n);
                array.set(n, array.get(m));
                array.set(m, temp);
            }
        }
    }
    public static void link(Node[] list, int firstAddress, List<Node> array) {
        while (firstAddress != -1) {
            array.add(list[firstAddress]);
            firstAddress = list[firstAddress].next;
        }
    }
}
class Node {
    int address;
    int data;
    int next;
    Node(int address, int data, int next) {
        this.address = address;
        this.data = data;
        this.next = next;
    }
}
```

